!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.ExtendedTypeChecker={})}(this,function(e){"use strict";function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function r(e,t){return e(t={exports:{}},t.exports),t.exports}var n=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r});t(n);n.hasOwn;var o=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var r,o=(r=n)&&"object"==typeof r&&"default"in r?r.default:r;const s="(Arguments)",c="(ReturnValue)";function i(e){if(!(this instanceof i))return new i(e);this.value=e}function p(){return this.value}i.prototype.toString=p,i.prototype.valueOf=p,i.prototype[Symbol.toPrimitive]=p;const a=e=>e.reduce((e,t)=>t instanceof i?`${e}${t}`:String(parseInt(t,10))===t?`${e}[${t}]`:/^[a-z][\w$]*$/i.test(t)?e?`${e}.${t}`:t:`${e}["${t}"]`,""),u=(e,t,r,n,o,s)=>{if(!n)return!0;const c=t[r];if(c){if(c!==n)return o(e,a([...s,r]),c,n),!1}else t[r]=n;return!0},l=({types:e,errorReporter:t},r,n=[])=>{const s=r.types;for(const r in s)if(o(s,r)){const o=s[r],c=e[r];o&&c&&c!==o?t("(Merge)",a([...n,r]),c,o):e[r]=o}return{types:e,errorReporter:t}},y=e=>void 0===e?"":e instanceof Array?"array":typeof e,f=e=>{return function(t,r,n,o,s){const{types:c,errorReporter:i}=o,p=this.getTypeString(n);return u(e,c,r,p,i,s)}},g=f("(GetProperty)"),h=f("(SetProperty)");class d{constructor(){this.collectTypesOnInit=!0,this.getTypeString=y,this.mergeConfigs=l}init(e,t,r=null){let n={};return r?n=r:this.collectTypesOnInit&&Object.keys(e).forEach(t=>{n[t]=y(e[t])}),{types:n,errorReporter:t}}getProperty(e,t,r,n,o){return g.call(this,e,t,r,n,o)}setProperty(e,t,r,n,o){return h.call(this,e,t,r,n,o)}arguments(e,t,r,n,o){const{types:c,errorReporter:i}=n,{length:p}=r;let a=!0;for(let e=0;e<p;e++){const t=this.getTypeString(r[e]);a=u(s,c,String(e),t,i,o)&&a}return a}returnValue(e,t,r,n,o){const{types:s,errorReporter:p}=n,a=this.getTypeString(r);return u(c,s,i(c),a,p,o)}}t.MERGE="(Merge)",t.ARGUMENTS=s,t.GET_PROPERTY="(GetProperty)",t.RETURN_VALUE=c,t.SET_PROPERTY="(SetProperty)",t.buildPath=a,t.AsIs=i,t.checkPrimitiveType=u,t.mergeConfigs=l,t.getTypeString=y,t.propertyCheckerFactory=f,t.PrimitiveTypeChecker=d,t.default=d}),s=t(o),c=(o.MERGE,o.ARGUMENTS),i=o.GET_PROPERTY,p=o.RETURN_VALUE,a=o.SET_PROPERTY,u=(o.buildPath,o.AsIs),l=o.checkPrimitiveType,y=(o.mergeConfigs,o.getTypeString,o.propertyCheckerFactory,o.PrimitiveTypeChecker,r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});const r=(e=>(t,r)=>Boolean(t&&e.call(t,r)))(Object.prototype.hasOwnProperty);t.hasOwn=r,t.default=r}));t(y);y.hasOwn;var f=r(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var r,n=(r=y)&&"object"==typeof r&&"default"in r?r.default:r;let o=null;const s=()=>o,c=()=>({wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1}),i={wrapFunctionReturnValues:!0,wrapFunctionArguments:!1,wrapSetPropertyValues:!0,ignorePrototypeMethods:!1},p=(e,t=null)=>n(t,e)?t[e]:i[e],a=(e,t,r,n)=>`${e}Error on "${t}" instead of "${r}" received "${n}"`,u=(e,t,r,n)=>console.error(a(e,t,r,n));let l=u;const f=()=>l;let g=!0;const h=()=>g,d=Symbol("type-checkers::info"),T=(e={})=>Object.assign({},e),P=e=>e?e[d]:void 0,R=(e,t)=>{e&&t&&(e[d]=t)},O=e=>!!P(e),E=(e,t,r)=>{delete e[t],r&&(e[t]=r)},m=(e,t,r)=>{E(e,t,P(r))},k=(e,t)=>e[t],C=(e,t)=>{const{deep:r,checker:o,children:s,config:c,names:i}=e;return o===t.checker?(e.deep=r||t.deep,e.children=((e,t)=>{for(const r in t)n(e,r)?e[r]=C(e[r],t[r]):e[r]=t[r];return e})(s,t.children),e.config=o.mergeConfigs(c,t.config,i)):console.error("TypeChecked objects can be merged only if using exactly same instance of type checker."),e},_=Symbol("type-checkers::target"),b={object:!0,function:!0},S=e=>Boolean(e&&b[typeof e]),w=e=>Boolean(e&&e[_]),x=(e,t,r,n)=>{if(!S(n))return n;let o=n;if(!w(n)){const{children:s}=t,c=k(s,r);if(c)o=e(n,{info:c});else{const{deep:c,names:i,checker:p}=t;o=e(n,{deep:c,names:[...i,r],checker:p}),m(s,r,o)}}return o};let I,A,j;const V=e=>e instanceof Function?(e=>new Proxy(e,{get:I,set:A,apply:j,construct:j}))(e):(e=>new Proxy(e,{get:I,set:A}))(e),v=(e,{deep:t=!0,names:r=[],config:n=null,children:o=null,checker:c=s(),info:i=null}={})=>i||((e,t,r=!0,n=[],o=T())=>({checker:e,config:t,deep:r,names:n,children:o}))(c,c.init(e,f(),n),t,r,T(o)),F=(e,t)=>S(e)&&h()&&!w(e)?(R(e,v(e,t)),V(e)):e;I=(e=>(t,r)=>{const o=t[r];if(r===d)return o;if(r===_)return t;const s=P(t),{names:c,config:i,checker:a}=s;return a.getProperty&&a.getProperty(t,r,o,i,c),!S(o)||w(o)||((e,t,r,o)=>!!(o instanceof Function&&!n(e,r)&&p("ignorePrototypeMethods",t)))(t,s,r,o)?o:((e,t,r,n)=>{const o=P(t),{deep:s,children:c,names:i,checker:p}=o;if(s||n instanceof Function){const t=k(c,r);t?n=e(n,{info:t}):(n=e(n,{deep:s,names:[...i,r],checker:p}),m(c,r,n))}return n})(e,t,r,o)})(F),A=(e=>(t,r,n)=>{if(r===_)throw new Error(`"${_}" is a virtual property and cannot be set`);return((e,t,r)=>{if(t===d){let n=P(e);return n=n&&r&&n!==r?C(n,r):r,e[t]=n,!0}if(!S(r)){const{names:n,config:o,checker:s}=P(e);return s.setProperty&&s.setProperty(e,t,r,o,n),e[t]=r,!0}return!1})(t,r,n)||((e,t,r,n)=>{const o=P(t),{deep:s,names:c,checker:i,config:a,children:u}=o;if(i.setProperty&&i.setProperty(t,r,n,a,c),p("wrapSetPropertyValues",o)){if(!w(n)){const t=k(u,r);n=e(n,t?{info:t}:{deep:s,names:[...c,r],checker:i})}m(u,r,n)}return t[r]=n,!0})(e,t,r,n)})(F),j=(e=>(t,r,n)=>{const o=P(t),{names:s,config:c,checker:i}=o;i.arguments&&i.arguments(t,r,n,c,s),n=((e,t,r)=>{const n=P(t);if(p("wrapFunctionArguments",n)){const{length:t}=r;for(let o=0;o<t;o++)r[o]=x(e,n,String(o),r[o])}return r})(e,t,n);let a=t.apply(r,n);return i.returnValue&&i.returnValue(t,r,a,c,s),p("wrapFunctionReturnValues",o)&&(a=x(e,o,"returnValue",a)),a})(F);const N=(e,t)=>{const r=v(e,t),{deep:n,names:o,checker:s,config:c,children:i}=r;return Object.keys(e).forEach(t=>{const r=e[t];if(s.getProperty(e,t,r,c,o),"object"==typeof r){let e=k(i,t);e?N(r,{info:e}):(e=N(r,{deep:n,names:[...o,t],checker:s}),E(i,t,e))}}),R(e,r),r};t.getDefaultTypeChecker=s,t.setDefaultTypeChecker=(e=>{o=e}),t.PROXY_WRAP_FUNCTION_RETURN_VALUES="wrapFunctionReturnValues",t.PROXY_WRAP_FUNCTION_ARGUMENTS="wrapFunctionArguments",t.PROXY_WRAP_SET_PROPERTY_VALUES="wrapSetPropertyValues",t.PROXY_IGNORE_PROTOTYPE_METHODS="ignorePrototypeMethods",t.getDefaultProxyConfig=c,t.setProxyConfig=(e=>Object.assign(i,e)),t.getProxyConfig=(()=>Object.assign({},i)),t.create=F,t.createDeep=((e,t)=>e&&"object"==typeof e&&h()&&!w(e)?(N(e,t),V(e)):e),t.ConsoleErrorReporter=u,t.ConsoleWarnReporter=((e,t,r,n)=>console.warn(a(e,t,r,n))),t.ThrowErrorReporter=((e,t,r,n)=>{throw new Error(a(e,t,r,n))}),t.getErrorReporter=f,t.setErrorReporter=(e=>{l=e}),t.isEnabled=h,t.setEnabled=((e=!0)=>{g=!!e}),t.getTargetInfo=P,t.setTargetInfo=R,t.hasTargetInfo=O,t.getTargetTypeChecker=(e=>e&&e[d]?e[d].checker:void 0),t.getTargetTypeCheckerConfig=(e=>{if(e&&e[d])return e[d].config}),t.mergeTargetInfo=C,t.getOriginalTarget=(e=>e[_]||e),t.merge=((e,...t)=>{let r={};return h()&&(e||(e={info:P(t.find(e=>O(e))),deep:!1}),r=F(r,e)),Object.assign(r,...t)}),t.properties=((e,t,...r)=>{if(!h())return e;if(!S(e))throw new Error("Target must be a valid object.");if(Object.isFrozen(e)||Object.isSealed(e))throw new Error("Target object should not be sealed or frozen.");r.length||(r=Object.keys(e));const{length:n}=r;for(let o=0;o<n;o+=1){const n=r[o],{writable:s,get:c,set:i}=Object.getOwnPropertyDescriptor(e,n);if(c&&i||s){const r=e[n];S(r)&&!w(r)&&(e[n]=F(r,t))}}return e}),t.isTypeChecked=w,t.isValidTarget=S,t.default=F});t(f);f.getDefaultTypeChecker,f.setDefaultTypeChecker,f.PROXY_WRAP_FUNCTION_RETURN_VALUES,f.PROXY_WRAP_FUNCTION_ARGUMENTS,f.PROXY_WRAP_SET_PROPERTY_VALUES,f.PROXY_IGNORE_PROTOTYPE_METHODS,f.getDefaultProxyConfig,f.setProxyConfig,f.getProxyConfig,f.create,f.createDeep,f.ConsoleErrorReporter,f.ConsoleWarnReporter,f.ThrowErrorReporter,f.getErrorReporter,f.setErrorReporter,f.isEnabled,f.setEnabled,f.getTargetInfo,f.setTargetInfo,f.hasTargetInfo;var g=f.getTargetTypeChecker,h=f.getTargetTypeCheckerConfig;f.mergeTargetInfo,f.getOriginalTarget,f.merge,f.properties,f.isTypeChecked,f.isValidTarget;const d=[Array],T="(Index)",P=e=>e&&d.indexOf(e.constructor)>=0,R=e=>{d.push(e)},O=(e,t)=>{const r=h(e);r&&(r.types[T]=t||"")},E=(e,t)=>{O(e,g(e).getTypeString(t))},m=(e,t,r)=>{const{types:n}=h(e);delete n[t],r&&(n[t]=r)},k=(e,t)=>{const{types:r}=h(e);delete r[c],t&&(r[c]=t)},C=(e,t)=>{const{types:r}=h(e);delete r[p],t&&(r[p]=t)},_=(e,t)=>{const{types:r}=h(e);delete r[T],t&&(r[T]=t)};class b extends s{constructor(...e){var t;return t=super(...e),this.areArrayElementsOfSameType=!0,this.replacePropertyTypeCheck=m,this.replaceArgumentsTypeCheck=k,this.replaceReturnValueTypeCheck=C,this.replaceIndexedTypeCheck=_,this.isIndexAccessTarget=P,this.registerIndexBasedClass=R,this.setIndexValueType=O,this.setIndexValueTypeBy=E,t}init(e,t,r=null){const n={};if(r||!this.collectTypesOnInit||!this.areArrayElementsOfSameType||!P(e))return super.init(e,t,r);{const{length:t}=e;for(let r=0;r<t;r+=1){const t=this.getTypeString(e[r]);if(t){n[T]=t;break}}}return{types:n,errorReporter:t}}getProperty(e,t,r,n,o){return this.areArrayElementsOfSameType&&P(e)?this.getIndexProperty(e,T,r,n,o):this.getNamedProperty(e,t,r,n,o)}getIndexProperty(e,t,r,n,o){const{types:s,errorReporter:c}=n,p=s[t];if(p instanceof Function)return p(i,e,t,r,n,o);const a=this.getTypeString(r);return l(i,s,u(T),a,c,o)}getNamedProperty(e,t,r,n,o){const s=n.types[t];return s instanceof Function?s(i,e,t,r,n,o):super.getProperty(e,t,r,n,o)}setProperty(e,t,r,n,o){return this.areArrayElementsOfSameType&&P(e)?this.setIndexProperty(e,T,r,n,o):this.setNamedProperty(e,t,r,n,o)}setIndexProperty(e,t,r,n,o){const{types:s,errorReporter:c}=n,i=s[t];if(i instanceof Function)return i(a,e,t,r,n,o);const p=this.getTypeString(r);return l(a,s,u(T),p,c,o)}setNamedProperty(e,t,r,n,o){const s=n.types[t];return s instanceof Function?s(a,e,t,r,n,o):super.setProperty(e,t,r,n,o)}arguments(e,t,r,n,o){const s=n.types[c];return s instanceof Function?s(c,e,r,n,o):super.arguments(e,t,r,n,o)}returnValue(e,t,r,n,o){const s=n.types[p];return s instanceof Function?s(p,e,r,n,o):super.returnValue(e,t,r,n,o)}}var S=Object.freeze({isIndexAccessTarget:P,registerIndexBasedClass:R,setIndexValueType:O,setIndexValueTypeBy:E,replaceArgumentsTypeCheck:k,replaceIndexedTypeCheck:_,replacePropertyTypeCheck:m,replaceReturnValueTypeCheck:C,ExtendedTypeChecker:b,default:b}),w=S&&b||S,x=r(function(e,t){f.setDefaultTypeChecker(new w.ExtendedTypeChecker),Object.assign(t,o,w,f)});e.default=x,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=extended-type-checker.min.js.map
