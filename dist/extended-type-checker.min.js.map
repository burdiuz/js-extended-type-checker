{"version":3,"file":"extended-type-checker.min.js","sources":["../node_modules/@actualwave/type-checker-simple-reporting/index.js","../node_modules/@actualwave/has-own/has-own.js","../node_modules/@actualwave/map-of-sets/index.js","../node_modules/@actualwave/type-checker-levels-storage/index.js","../node_modules/@actualwave/primitive-type-checker/index.js","../node_modules/@actualwave/get-class/get-class.js","../node_modules/@actualwave/closure-value/closure-value.js","../node_modules/@actualwave/path-sequence-to-string/index.js","../node_modules/@actualwave/is-function/is-function.js","../node_modules/@actualwave/with-proxy/with-proxy.js","../node_modules/@actualwave/type-checkers/index.js","../source/indexed.js","../source/extended.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable import/prefer-default-export */\n\nconst constructErrorString = (action, name, required, received) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${received}\"`;\n\n/* eslint-disable no-console */\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\n/* eslint-disable import/prefer-default-export */\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, receivedTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, receivedTypeString));\n};\n\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass MapOfSets {\n  constructor() {\n    this.storage = new Map();\n  }\n  /**\r\n   * Check if key exists\r\n   * @param {*} key\r\n   */\n\n\n  has(key) {\n    const values = this.storage.get(key);\n    return values && values.size;\n  }\n  /**\r\n   * Check if value exists for key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  hasValue(key, value) {\n    const values = this.storage.get(key);\n    return values && values.has(value);\n  }\n  /**\r\n   * Get Set of values for key\r\n   * @param {*} key\r\n   */\n\n\n  get(key) {\n    return this.storage.get(key);\n  }\n  /**\r\n   * List values for key, returns empty array if no key nor values stored\r\n   * @param {*} key\r\n   */\n\n\n  list(key) {\n    const values = this.storage.get(key);\n    return values ? Array.from(values) : [];\n  }\n  /**\r\n   * Call callback for each value of each key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {Function} callback\r\n   */\n\n\n  forEach(callback) {\n    this.storage.forEach((values, key) => values.forEach(value => callback(value, key, this)));\n  }\n  /**\r\n   * Call callback function for each value of specified key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {*} key\r\n   * @param {Function} callback\r\n   */\n\n\n  eachValue(key, callback) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.forEach(value => callback(value, key, this));\n    }\n  }\n  /**\r\n   * Add to new value to key.\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  add(key, value) {\n    if (!value) return;\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.add(value);\n    } else {\n      this.storage.set(key, new Set([value]));\n    }\n  }\n  /**\r\n   * Replace all values for key\r\n   * @param {*} key\r\n   * @param {Set} types\r\n   */\n\n\n  set(key, values) {\n    if (!values || values.size === 0) {\n      this.remove(key);\n      return;\n    }\n\n    this.storage.set(key, new Set(values));\n  }\n  /**\r\n   * Remove all values for key\r\n   * @param {*} key\r\n   */\n\n\n  remove(key) {\n    this.storage.delete(key);\n  }\n  /**\r\n   * Remove single value from key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  removeValue(key, value) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.delete(value);\n\n      if (!values.size) {\n        this.remove(key);\n      }\n    }\n  }\n  /**\r\n   * Clone all key-value stores\r\n   */\n\n\n  clone() {\n    const target = new MapOfSets();\n    this.storage.forEach((values, key) => target.set(key, new Set(values)));\n    return target;\n  }\n\n}\nconst createMapOfSets = () => new MapOfSets();\n\nexports.MapOfSets = MapOfSets;\nexports.createMapOfSets = createMapOfSets;\nexports.default = MapOfSets;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\nvar MapOfSets = _interopDefault(require('@actualwave/map-of-sets'));\n\n/**\n * Do not check or report type inconsistency\n */\nconst REPORT_NEVER = 'never';\n/**\n * Report type inconsistency once, i.e. record all types and report new\n */\nconst REPORT_ONCE = 'once';\n/**\n * Report whenever type is inconsistent with initial\n */\nconst REPORT_ALL = 'all';\n\nconst REPORT_KEY = Symbol('type-checkers:report-level');\nconst PROPERTY_REPORT_KEY = Symbol('type-checkers:property-report-level');\n\nlet globalReportingLevel = REPORT_ALL;\n\nconst validateReportingLevel = level => {\n  switch (level) {\n    case REPORT_NEVER:\n    case REPORT_ONCE:\n      return level;\n    default:\n      return REPORT_ALL;\n  }\n};\n\nconst setGlobalReportingLevel = level => {\n  globalReportingLevel = validateReportingLevel(level);\n};\n\nconst getGlobalReportingLevel = () => globalReportingLevel;\n\nconst setTargetGeneralReportingLevel = (target, level) => {\n  if (level) {\n    target[REPORT_KEY] = validateReportingLevel(level);\n  } else {\n    delete target[REPORT_KEY];\n  }\n};\n\nconst setTargetPropertyReportingLevel = (target, perPropertyLevels) => {\n  if (!perPropertyLevels) {\n    delete target[PROPERTY_REPORT_KEY];\n    return;\n  }\n\n  target[PROPERTY_REPORT_KEY] = Object.keys(perPropertyLevels).reduce((levels, prop) => {\n    levels[prop] = validateReportingLevel(perPropertyLevels[prop]);\n    return levels;\n  }, {});\n};\n\nconst setReportingLevel = (target, generalLevel, perPropertyLevels) => {\n  setTargetGeneralReportingLevel(target, generalLevel);\n  setTargetPropertyReportingLevel(target, perPropertyLevels);\n};\n\nconst getTargetReportingLevel = (target, key) => {\n  if (hasOwn(target[PROPERTY_REPORT_KEY], key)) {\n    return target[PROPERTY_REPORT_KEY][key];\n  }\n\n  return target[REPORT_KEY];\n};\n\nconst getReportingLevel = (target, key) => {\n  let level = getTargetReportingLevel(target, key);\n\n  if (!level) {\n    level = getTargetReportingLevel(target.constructor, key);\n  }\n\n  return level || getGlobalReportingLevel();\n};\n\n/**\n *\n * @param {any} key\n * @param {Set} target\n * @param {Set} source\n */\nconst defaultMergeStrategy = (key, target, source) => {\n  source.forEach(type => {\n    if (!target.has(type)) {\n      target.add(type);\n    }\n  });\n\n  return target;\n};\n\nclass TypeInfoStorage extends MapOfSets {\n  /**\n   * Add to type information for specified key.\n   * @param {*} key\n   * @param {*} type\n   * @param {Number} level\n   */\n  add(key, type, level) {\n    if (!type) return;\n\n    switch (level) {\n      case REPORT_NEVER:\n        this.remove(key);\n        break;\n      case REPORT_ONCE:\n        super.add(key, type);\n        break;\n      case REPORT_ALL:\n      default:\n        {\n          const types = this.storage.get(key);\n\n          if (!types || !types.size) {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n    }\n  }\n\n  addFor(key, type, target) {\n    this.add(key, type, getReportingLevel(target, key));\n  }\n\n  /**\n   * Replace types information for specific key\n   * @param {*} key\n   * @param {Set} types\n   * @param {Number} level\n   */\n  set(key, types, level) {\n    if (!types || types.size === 0 || level === REPORT_NEVER) {\n      this.remove(key);\n      return;\n    }\n\n    super.set(key, types);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Set} types\n   * @param {Object} target\n   */\n  setFor(key, types, target) {\n    return this.set(key, types, getReportingLevel(target, key));\n  }\n\n  clone() {\n    const target = new TypeInfoStorage();\n    this.storage.forEach((types, key) => target.set(key, new Set(types)));\n\n    return target;\n  }\n\n  /**\n   * Copy types from current storage to storage passed as first argument.\n   * @param {Map} storage\n   * @param {Object} [target]\n   * @param {Function} [mergeStrategy]\n   */\n  copyTo(storage, target, mergeStrategy = defaultMergeStrategy) {\n    this.storage.forEach((types, key) => {\n      const level = validateReportingLevel(target && getReportingLevel(target, key));\n\n      switch (level) {\n        case REPORT_ALL:\n        case REPORT_ONCE:\n          if (storage.has(key)) {\n            storage.set(key, mergeStrategy(key, storage.get(key), types, level), level);\n          } else {\n            storage.set(key, new Set(types));\n          }\n          break;\n        case REPORT_NEVER:\n        default:\n          break;\n      }\n    });\n\n    return storage;\n  }\n}\n\nconst createTypesStorage = () => new TypeInfoStorage();\n\nexports.REPORT_ALL = REPORT_ALL;\nexports.REPORT_NEVER = REPORT_NEVER;\nexports.REPORT_ONCE = REPORT_ONCE;\nexports.createTypesStorage = createTypesStorage;\nexports.defaultMergeStrategy = defaultMergeStrategy;\nexports.getGlobalReportingLevel = getGlobalReportingLevel;\nexports.setGlobalReportingLevel = setGlobalReportingLevel;\nexports.getReportingLevel = getReportingLevel;\nexports.setReportingLevel = setReportingLevel;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar typeCheckerSimpleReporting = require('@actualwave/type-checker-simple-reporting');\nvar typeCheckerLevelsStorage = require('@actualwave/type-checker-levels-storage');\n\nlet errorReporter = typeCheckerSimpleReporting.ConsoleErrorReporter;\nconst getErrorReporter = () => errorReporter;\nconst setErrorReporter = value => {\n  errorReporter = value;\n};\n\nconst MERGE = '(Merge)';\nconst GET_PROPERTY = '(GetProperty)';\nconst SET_PROPERTY = '(SetProperty)';\nconst ARGUMENTS = '(Arguments)';\nconst RETURN_VALUE = '(ReturnValue)';\nconst checkPrimitiveType = (action, storage, target, names, type) => {\n  if (!type) {\n    return true;\n  }\n\n  const {\n    lastName\n  } = names;\n  const missingType = storage.has(lastName) && !storage.hasValue(lastName, type);\n\n  if (missingType) {\n    const errorReporter = getErrorReporter();\n    errorReporter(action, names.toString(), storage.list(lastName).join(', '), type);\n  }\n\n  storage.addFor(lastName, type, target);\n  return !missingType;\n};\nconst getTypeValue = value => {\n  if (value === undefined) {\n    return '';\n  }\n\n  const type = typeof value;\n\n  if (type === 'object' && value instanceof Array) {\n    return 'array';\n  }\n\n  return type;\n};\n\n/* eslint-disable class-methods-use-this */\n\nclass PrimitiveTypeChecker {\n  constructor(collectTypesOnInit = true, enableGetChecker = true) {\n    this.collectTypesOnInit = collectTypesOnInit;\n    this.enableGetChecker = enableGetChecker;\n  }\n\n  init(target, cachedStorage = null) {\n    let storage;\n\n    if (cachedStorage) {\n      storage = cachedStorage;\n    } else if (this.collectTypesOnInit) {\n      storage = typeCheckerLevelsStorage.createTypesStorage();\n      Object.keys(target).forEach(key => storage.addFor(key, this.getTypeValue(target[key]), target));\n    }\n\n    return storage;\n  }\n\n  getTypeValue(value) {\n    return getTypeValue(value);\n  }\n\n  checkType(action, storage, target, names, type) {\n    return checkPrimitiveType(action, storage, target, names, type);\n  }\n  /**\n   * FIXME add function to @actualwave/type-checker-levels-storage to merge configs\n   * this function should accept storages and merge strategy callback which will\n   * receive type info and decide what should be merged and what not\n   */\n\n\n  mergeConfigs(storage, sourceStorage, names) {\n    const errorReporter = getErrorReporter();\n    sourceStorage.copyTo(storage, null, (key, target, source) => {\n      const targetFirstValue = target.values().next().value;\n      source.forEach(sourceType => {\n        if (!target.has(sourceType)) {\n          target.add(sourceType);\n\n          if (targetFirstValue) {\n            errorReporter(MERGE, names, targetFirstValue, sourceType);\n          }\n        }\n      });\n      return target;\n    });\n  }\n\n  getProperty(target, names, value, storage) {\n    if (!this.enableGetChecker) {\n      return true;\n    }\n\n    const type = this.getTypeValue(value);\n    return this.checkType(GET_PROPERTY, storage, target, names, type);\n  }\n\n  setProperty(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n    return this.checkType(SET_PROPERTY, storage, target, names, type);\n  }\n\n  arguments(target, names, args, storage) {\n    const {\n      length\n    } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeValue(args[index]);\n      const agrValid = this.checkType(ARGUMENTS, storage, target, names.clone(index), type);\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n    const callNames = names.clone();\n    callNames.appendCustomValue(RETURN_VALUE);\n    return this.checkType(RETURN_VALUE, storage, target, callNames, type);\n  }\n\n}\n\nconst createPrimitiveTypeChecker = (collectTypesOnInit = true, enableGetChecker = true) => new PrimitiveTypeChecker(collectTypesOnInit, enableGetChecker);\n\nexports.REPORT_ALL = typeCheckerLevelsStorage.REPORT_ALL;\nexports.REPORT_NEVER = typeCheckerLevelsStorage.REPORT_NEVER;\nexports.REPORT_ONCE = typeCheckerLevelsStorage.REPORT_ONCE;\nexports.getGlobalReportingLevel = typeCheckerLevelsStorage.getGlobalReportingLevel;\nexports.setGlobalReportingLevel = typeCheckerLevelsStorage.setGlobalReportingLevel;\nexports.getReportingLevel = typeCheckerLevelsStorage.getReportingLevel;\nexports.setReportingLevel = typeCheckerLevelsStorage.setReportingLevel;\nexports.MERGE = MERGE;\nexports.ARGUMENTS = ARGUMENTS;\nexports.GET_PROPERTY = GET_PROPERTY;\nexports.RETURN_VALUE = RETURN_VALUE;\nexports.SET_PROPERTY = SET_PROPERTY;\nexports.checkPrimitiveType = checkPrimitiveType;\nexports.getTypeValue = getTypeValue;\nexports.PrimitiveTypeChecker = PrimitiveTypeChecker;\nexports.createPrimitiveTypeChecker = createPrimitiveTypeChecker;\nexports.getErrorReporter = getErrorReporter;\nexports.setErrorReporter = setErrorReporter;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst getClass = (target) => {\n  if(target === null || target === undefined) {\n    return undefined;\n  }\n  \n  const proto = Object.getPrototypeOf(target);\n  \n  if (typeof proto === 'object') {\n    return proto.constructor;\n  }\n\n  return proto;\n};\n\nconst getParentClass = (target) => {\n  const def = getClass(target);\n  \n  return def && Object.getPrototypeOf(def);\n};\n\nconst getClassName = (value) => {\n  if (!value) return '';\n\n  const match = String(getClass(value)).match(\n    /^(?:[^\\(\\{\\s]*)(?:class|function)\\s+([\\w\\d_$]+)(?:\\s*\\(|\\s*\\{|\\s+extends)/,\n  );\n\n  return match ? match[1] : '';\n};\n\nexports.getClassName = getClassName;\nexports.getParentClass = getParentClass;\nexports.getClass = getClass;\nexports.default = getClass;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst singleValueFactory = (defaultValue = null, valueFormatter = (value) => value) => {\n  let value = defaultValue;\n\n  return {\n    getDefault: () => defaultValue,\n    get: () => value,\n    set: (newValue = defaultValue) => {\n      value = valueFormatter(newValue);\n    },\n  };\n};\n\nconst valuesMapFactory = (defaults = new Map(), valueFormatter = (key, value) => value) => {\n  const defaultValues = new Map(defaults);\n  const getDefault = () => new Map(defaultValues);\n\n  const values = getDefault();\n\n  return {\n    values,\n    getDefault,\n    copy: () => new Map(values),\n    delete: (key) => values.delete(key),\n    has: (key) => values.has(key),\n    set: (key, value) => values.set(key, valueFormatter(key, value)),\n    get: (key) => values.get(key),\n  };\n};\n\nconst valuesSetFactory = (defaults = new Set(), valueFormatter = (value) => value) => {\n  const defaultValues = new Set(defaults);\n  const getDefault = () => new Set(defaultValues);\n\n  const values = getDefault();\n\n  return {\n    values,\n    getDefault,\n    get: () => new Set(values),\n    delete: (value) => values.delete(value),\n    has: (value) => values.has(value),\n    add: (value) => values.add(valueFormatter(value)),\n  };\n};\n\nexports.singleValueFactory = singleValueFactory;\nexports.valuesMapFactory = valuesMapFactory;\nexports.valuesSetFactory = valuesSetFactory;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * Wrap any value with AsIs() to pass it to string as is without ant wrapping\n * or dot prior to name.\n * @param {*} value\n */\nfunction AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\n/**\n *\n * @param {String} str\n * @param {String|AsIs|Number} name\n */\nconst appendPathNameToString = (str, name) => {\n  const string = String(str) || '';\n\n  if (name instanceof AsIs) {\n    return `${string}${name}`;\n  }\n\n  if (typeof name === 'symbol') {\n    return `${string}[${String(name)}]`;\n  }\n\n  if (String(parseInt(name, 10)) === name) {\n    return `${string}[${name}]`;\n  }\n\n  if (/^[a-z_$][\\w\\d$_]*$/i.test(name)) {\n    return string ? `${string}.${name}` : name;\n  }\n\n  return `${string}[\"${name}\"]`;\n};\n\nclass PathSequence {\n  constructor(value) {\n    this.value = value ? String(value) : '';\n    this.lastName = undefined;\n  }\n\n  append(name) {\n    this.value = appendPathNameToString(this.value, name);\n    this.lastName = name;\n  }\n\n  appendCustomValue(customString) {\n    this.value = appendPathNameToString(this.value, AsIs(customString));\n    this.lastName = customString;\n  }\n\n  clone(nextName = undefined) {\n    const sequence = new PathSequence(this.value);\n\n    if (nextName === undefined) {\n      sequence.lastName = this.lastName;\n    } else {\n      sequence.append(nextName);\n    }\n\n    return sequence;\n  }\n\n  getLastName() {\n    return this.lastName;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value;\n  }\n}\n\n/**\n *\n * @returns {Array<String|Number|AsIs>}\n */\nconst createPathSequence = value => new PathSequence(value);\n\nexports.createPathSequence = createPathSequence;\nexports.default = PathSequence;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isFunction = (target) => (typeof target === 'function');\n\nexports.isFunction = isFunction;\nexports.default = isFunction;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst { isFunction } = require('@actualwave/is-function');\n\nconst withProxy = (handlers) => {\n  /*\n   have problems with using rest operator here, when in node_modules without additional \n   configurations, so using old style code\n  */\n  const { apply, construct } = handlers;\n\n  delete handlers.apply;\n  delete handlers.construct;\n\n  const functionHandlers = { ...handlers, construct, apply };\n\n  return (target) => new Proxy(target, isFunction(target) ? functionHandlers : handlers);\n};\n\nexports.withProxy = withProxy;\nexports.default = withProxy;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar closureValue = require('@actualwave/closure-value');\nvar getClass = require('@actualwave/get-class');\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\nvar pathSequenceToString = require('@actualwave/path-sequence-to-string');\nvar isFunction = _interopDefault(require('@actualwave/is-function'));\nvar withProxy = _interopDefault(require('@actualwave/with-proxy'));\n\nconst {\n  get: getDefaultTypeChecker,\n  set: setDefaultTypeChecker\n} = closureValue.singleValueFactory();\n\nconst {\n  get: isEnabled,\n  set: setEnabled\n} = closureValue.singleValueFactory(true, value => !!value);\n\n/*\n When ignoring class, its instances will never be wrapped.\n*/\n\nconst constructors = new Set();\nconst addIgnoredClasses = (...classes) => {\n  classes.forEach(constructor => {\n    if (constructor && !constructors.has(constructor)) {\n      constructors.add(constructor);\n    }\n  });\n};\nconst removeIgnoredClasses = (...classes) => {\n  classes.forEach(constructor => constructors.delete(constructor));\n};\nconst isIgnoredClass = constructor => constructors.has(constructor);\nconst isValueOfIgnoredClass = value => constructors.has(getClass.getClass(value));\n/**\n * Number, String, Boolean and Symbol will not pass\n *\n *  typeof === 'object' || typeof === 'function'\n *\n * check, so not need to add them.\n */\n\naddIgnoredClasses(Map, Set, Date, Error);\n\nconst WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nconst WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nconst WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nconst WRAP_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\nconst {\n  getDefault: getDefaultWrapConfig,\n  set: setWrapConfigValue,\n  get\n} = closureValue.valuesMapFactory([[WRAP_FUNCTION_RETURN_VALUES, true], [WRAP_FUNCTION_ARGUMENTS, false], [WRAP_SET_PROPERTY_VALUES, false], [WRAP_IGNORE_PROTOTYPE_METHODS, false]], (key, value) => !!value);\nconst getWrapConfigValue = (name, target) => {\n  let value;\n\n  if (target) {\n    value = target[name];\n  }\n\n  return value === undefined ? get(name) : value;\n};\n\n/*\n  I have had to apply custom key instead of name as is to\n  fix \"construtor\" issue. Since ordinary object has some\n  properties with values from start, these properties were\n  mustakenly returned as child info objects, for example, if\n  requesting hild info for \"constructor\" function of the target,\n  it returned class constructor which caused errors later,\n  when accesing info properties.\n\n  Converts Symbols and Numbers to String.\n\n  FIXME: Map might be fitting better.\n */\n\nconst getChildInfoKey = name => `@${String(name)}`;\n\nclass ChildrenCache {\n  constructor(children) {\n    if (children) {\n      this.cache = { ...children.cache\n      };\n    } else {\n      this.cache = {};\n    }\n  }\n\n  store(name, childInfo) {\n    const key = getChildInfoKey(name);\n\n    if (childInfo) {\n      this.cache[key] = childInfo;\n    } else {\n      delete this.cache[key];\n    }\n  }\n\n  get(name) {\n    return this.cache[getChildInfoKey(name)];\n  }\n\n  has(name) {\n    return !!this.cache[getChildInfoKey(name)];\n  }\n\n  remove(cache, name) {\n    return delete this.cache[getChildInfoKey(name)];\n  }\n\n  copy({\n    cache: sourceCache\n  }) {\n    Object.keys(sourceCache).forEach(key => {\n      if (hasOwn(this.cache, key)) {\n        this.cache[key].copy(sourceCache[key]);\n      } else {\n        this.cache[key] = sourceCache[key];\n      }\n    });\n    return this;\n  }\n\n}\n\nconst createChildrenCache = children => new ChildrenCache(children);\n\nconst INFO_KEY = Symbol('type-checkers::info');\nconst getTargetInfo = target => target ? target[INFO_KEY] : undefined;\nconst setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\nconst removeTargetInfo = target => delete target[INFO_KEY];\n\nclass TargetInfo {\n  constructor(checker, data = null, deep = true, names = pathSequenceToString.createPathSequence(), children = createChildrenCache()) {\n    this.checker = checker;\n    this.data = data;\n    this.deep = deep;\n    this.names = names;\n    this.children = children;\n  }\n\n  getChild(name) {\n    return this.children.get(name);\n  }\n\n  storeChildFrom(name, child) {\n    const info = getTargetInfo(child);\n\n    if (info) {\n      this.children.store(name, info);\n    }\n  }\n\n  createChildWithNames(names, value, data = null) {\n    const childInfo = new TargetInfo(this.checker, this.checker.init(value, data), this.deep, names);\n    this.children.store(names.lastName, childInfo);\n    return childInfo;\n  }\n\n  createChild(name, value, data = null) {\n    return this.createChildWithNames(this.names.clone(name), value, data);\n  }\n\n  copy({\n    deep,\n    checker,\n    children,\n    data,\n    names\n  }) {\n    if (this.checker === checker) {\n      this.deep = this.deep || deep;\n      this.children.copy(children);\n      this.data = checker.mergeConfigs(this.data, data, names);\n    } else {\n      console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n    }\n\n    return this;\n  }\n\n}\n\nconst createTargetInfo = (checker, data, deep, names, children) => new TargetInfo(checker, data, deep, names, children);\n\nconst getTypeChecker = target => {\n  if (target) {\n    const info = target[INFO_KEY];\n    return info && info.checker || undefined;\n  }\n\n  return undefined;\n};\nconst getTypeCheckerData = target => {\n  if (target) {\n    const info = target[INFO_KEY];\n    return info && info.data || undefined;\n  }\n\n  return undefined;\n};\n\nconst TARGET_KEY = Symbol('type-checkers::target');\nconst isSymbol = value => typeof value === 'symbol';\nconst isOfWrappableType = target => {\n  const type = typeof target;\n  return Boolean(target) && (type === 'function' || type === 'object') && !isValueOfIgnoredClass(target);\n};\nconst isWrapped = target => Boolean(target && target[TARGET_KEY]);\nconst isWrappable = target => isOfWrappableType(target) && !isWrapped(target);\nconst unwrap = target => target && target[TARGET_KEY] || target;\nconst setWrapConfigTo = (target, key, value) => {\n  if (!isWrapped(target)) {\n    return false;\n  }\n\n  const info = getTargetInfo(target);\n\n  switch (key) {\n    case WRAP_FUNCTION_RETURN_VALUES:\n    case WRAP_FUNCTION_ARGUMENTS:\n    case WRAP_SET_PROPERTY_VALUES:\n    case WRAP_IGNORE_PROTOTYPE_METHODS:\n      info[key] = !!value;\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst getTargetProperty = (wrapFn, target, names, value) => {\n  const info = getTargetInfo(target);\n  const {\n    deep\n  } = info;\n\n  if (deep || isFunction(value)) {\n    const {\n      lastName: property\n    } = names;\n    const childInfo = info.getChild(property);\n\n    if (childInfo) {\n      return wrapFn(value, childInfo);\n    }\n\n    return wrapFn(value, info.createChildWithNames(names, value));\n  }\n\n  return value;\n};\n/**\n * Skips prototype methods if they are ignored by config\n */\n\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (isFunction(value) && !hasOwn(target, property) && getWrapConfigValue(WRAP_IGNORE_PROTOTYPE_METHODS, info)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getPropertyFactory = wrapFn => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    Also it allows \"unwrapping\" target.\n    */\n  }\n\n  if (property === TARGET_KEY) {\n    return target;\n  }\n\n  if (isSymbol(property)) {\n    return target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const {\n    names,\n    data,\n    checker\n  } = info;\n  const nextNames = names.clone(property);\n\n  if (checker.getProperty) {\n    checker.getProperty(target, nextNames, value, data);\n  }\n\n  if (!isWrappable(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(wrapFn, target, nextNames, value);\n};\n\nconst setNonTargetProperty = (target, property, value) => {\n  const {\n    names,\n    data,\n    checker\n  } = getTargetInfo(target);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, names.clone(property), value, data);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setTargetProperty = (wrapFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const {\n    names,\n    checker,\n    data\n  } = info;\n  const childInfo = info.getChild(property);\n  const nextNames = childInfo ? childInfo.names : names.clone(property);\n\n  if (checker.setProperty) {\n    checker.setProperty(target, nextNames, value, data);\n  }\n\n  if (childInfo) {\n    value = wrapFn(value, childInfo);\n  } else {\n    value = wrapFn(value, info.createChildWithNames(nextNames, value));\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst updateTargetInfo = (target, value) => {\n  let info = getTargetInfo(target);\n\n  if (info && value && info !== value) {\n    info.copy(value);\n  } else {\n    info = value;\n  }\n\n  target[INFO_KEY] = info;\n  return true;\n};\n\nconst setPropertyFactory = wrapFn => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  if (property === INFO_KEY) {\n    return updateTargetInfo(target, value);\n  }\n\n  if (isSymbol(property)) {\n    return updateTargetInfo(target, value);\n  }\n\n  const info = getTargetInfo(target);\n\n  if (isWrappable(value) && getWrapConfigValue(WRAP_SET_PROPERTY_VALUES, info)) {\n    return setTargetProperty(wrapFn, target, property, value);\n  }\n\n  return setNonTargetProperty(target, property, value);\n};\n\nconst getTypeCheckedChild = (wrapFn, info, name, value) => {\n  if (!isWrappable(value)) {\n    return value;\n  }\n\n  const childInfo = info.getChild(name);\n\n  if (childInfo) {\n    return wrapFn(value, childInfo);\n  }\n\n  return wrapFn(value, info.createChild(name, value));\n};\nconst getTargetArguments = (wrapFn, info, argumentsList) => {\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    const {\n      length\n    } = argumentsList;\n\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(wrapFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst applyFunctionFactory = wrapFn => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const {\n    names,\n    data,\n    checker\n  } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, names, argumentsList, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, names, result, data, thisArg);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nconst constructFactory = wrapFn => (Target, argumentsList) => {\n  const info = getTargetInfo(Target);\n  const {\n    names,\n    data,\n    checker\n  } = info;\n\n  if (checker.arguments) {\n    checker.arguments(Target, names, argumentsList, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_ARGUMENTS, info)) {\n    argumentsList = getTargetArguments(wrapFn, info, argumentsList);\n  }\n\n  let result = new Target(...argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(Target, names, result, data);\n  }\n\n  if (getWrapConfigValue(WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(wrapFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nconst deletePropertyFactory = () => (target, property) => {\n  if (property === INFO_KEY) {\n    return delete target[property];\n  }\n\n  if (property === TARGET_KEY) {\n    return false;\n  }\n\n  if (isSymbol(property)) {\n    return delete target[property];\n  }\n\n  const info = getTargetInfo(target);\n  const {\n    names,\n    data,\n    checker\n  } = info;\n  checker.deleteProperty(target, names.clone(property), data);\n  return delete target[property];\n};\n\n/* eslint-disable import/prefer-default-export */\nconst createInfoFromOptions = (target, {\n  checker = getDefaultTypeChecker(),\n  deep,\n  name,\n  data,\n  children,\n  info = null // exclusive option, if set other options being ignored\n\n} = {}) => info || createTargetInfo(checker, checker.init(target, data), deep, pathSequenceToString.createPathSequence(name), children);\n\nconst generateHandlers = (create, config = null) => ({\n  get: (!config || config.get) && getPropertyFactory(create),\n  set: (!config || config.set) && setPropertyFactory(create),\n  apply: (!config || config.apply) && applyFunctionFactory(create),\n  construct: (!config || config.construct) && constructFactory(create),\n  deleteProperty: (!config || config.deleteProperty) && deletePropertyFactory(create)\n});\n\nconst createWrapFactory = proxyConfig => {\n  let wrapInternal;\n\n  const assignInfoAndWrap = (target, info) => {\n    setTargetInfo(target, info);\n    return wrapInternal(target);\n  };\n\n  const handlers = generateHandlers(assignInfoAndWrap, proxyConfig);\n  wrapInternal = withProxy(handlers);\n  return assignInfoAndWrap;\n};\nconst wrap = (target, options = null, proxyConfig = null) => {\n  if (!isWrappable(target) || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options || undefined);\n  return wrapInternal(target, info);\n};\n\n/* eslint-disable import/prefer-default-export */\n\nconst deepInitializer = (target, info) => {\n  const {\n    names,\n    checker,\n    data\n  } = info;\n  Object.keys(target).forEach(name => {\n    const value = target[name];\n    const nextNames = names.clone(name);\n\n    if (checker.getProperty) {\n      checker.getProperty(target, nextNames, value, data);\n    }\n\n    if (isWrappable(value)) {\n      let childInfo = info.getChild(name);\n\n      if (!childInfo) {\n        childInfo = info.createChildWithNames(nextNames, value);\n      }\n\n      deepInitializer(value, childInfo);\n    }\n  });\n  setTargetInfo(target, info);\n  return info;\n};\n\nconst wrapDeep = (target, options, proxyConfig = null) => {\n  if (!isWrappable(target) || typeof target !== 'object' || !isEnabled()) {\n    return target;\n  }\n\n  const wrapInternal = createWrapFactory(proxyConfig);\n  const info = createInfoFromOptions(target, options);\n  deepInitializer(target, info);\n  return wrapInternal(target, info);\n};\n\nconst findWrapped = list => list.find(isWrapped);\n/**\n * Merge all objects and return new. If any of source objects were wrapped,\n * resulting object will be wrapped.\n * @param  {...any} sources\n */\n\n\nconst merge = (...sources) => {\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign({}, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n  return Object.assign(wrap({}, {\n    info\n  }), ...sources);\n};\n/**\n * Calls merge() and forces wrapped result.\n * @param {*} options\n * @param  {...Object} sources\n */\n\nmerge.options = (options, ...sources) => merge(wrap({}, options), ...sources);\n/**\n * Assign properties from source objects to target. If target or any of sources\n * were wrapped, resulting object will be wrapped.\n * @param {*} target\n * @param  {...any} sources\n */\n\n\nconst assign = (target, ...sources) => {\n  if (isWrapped(target)) {\n    return Object.assign(target, ...sources);\n  }\n\n  const wrapped = findWrapped(sources);\n\n  if (!wrapped) {\n    return Object.assign(target, ...sources);\n  }\n\n  const info = getTargetInfo(wrapped);\n  return Object.assign(wrap(target, {\n    info\n  }), ...sources);\n};\n/**\n * calls assign() and forces wrapped result.\n * @param {*} options\n * @param {Object} target\n * @param  {...Object} sources\n */\n\nassign.options = (options, target, ...sources) => assign(wrap(target, options), ...sources);\n\nexports.getDefaultTypeChecker = getDefaultTypeChecker;\nexports.setDefaultTypeChecker = setDefaultTypeChecker;\nexports.isEnabled = isEnabled;\nexports.setEnabled = setEnabled;\nexports.addIgnoredClasses = addIgnoredClasses;\nexports.isIgnoredClass = isIgnoredClass;\nexports.isValueOfIgnoredClass = isValueOfIgnoredClass;\nexports.removeIgnoredClasses = removeIgnoredClasses;\nexports.setWrapConfigValue = setWrapConfigValue;\nexports.getWrapConfigValue = getWrapConfigValue;\nexports.getTargetInfo = getTargetInfo;\nexports.getTypeChecker = getTypeChecker;\nexports.getTypeCheckerData = getTypeCheckerData;\nexports.removeTargetInfo = removeTargetInfo;\nexports.wrap = wrap;\nexports.wrapDeep = wrapDeep;\nexports.isWrappable = isWrappable;\nexports.isWrapped = isWrapped;\nexports.unwrap = unwrap;\nexports.setWrapConfigTo = setWrapConfigTo;\nexports.assign = assign;\nexports.merge = merge;\n//# sourceMappingURL=index.js.map\n","import { getClass } from '@actualwave/get-class';\nimport { getTypeValue } from '@actualwave/primitive-type-checker';\nimport { getTypeCheckerData } from '@actualwave/type-checkers';\n\nconst indexBasedClasses = new Set([Array]);\n\nexport const INDEX = '(Index)';\n\nexport const isIndexAccessTarget = (target) => !!target && indexBasedClasses.has(getClass(target));\n\nexport const registerIndexBasedClass = (constructor) => {\n  indexBasedClasses.add(constructor);\n};\n\nexport const setIndexValueType = (target, type) => {\n  const storage = getTypeCheckerData(target);\n\n  if (storage && type) {\n    storage.set(INDEX, new Set([type]));\n  }\n};\n\nexport const setIndexValueTypeBy = (target, value) => {\n  setIndexValueType(target, getTypeValue(value));\n};\n","import { createTypesStorage } from '@actualwave/type-checker-levels-storage';\r\nimport isFunction from '@actualwave/is-function';\r\n\r\nimport PrimitiveTypeChecker, {\r\n  GET_PROPERTY,\r\n  SET_PROPERTY,\r\n} from '@actualwave/primitive-type-checker';\r\n\r\nimport { INDEX, isIndexAccessTarget } from './indexed';\r\n\r\nclass ExtendedTypeChecker extends PrimitiveTypeChecker {\r\n  constructor({\r\n    collectTypesOnInit = true,\r\n    enableGetChecker = true,\r\n    areArrayElementsOfSameType = true,\r\n    customGetTypeValue = undefined,\r\n  } = {}) {\r\n    super(collectTypesOnInit, enableGetChecker);\r\n\r\n    this.areArrayElementsOfSameType = areArrayElementsOfSameType;\r\n    this.customGetTypeValue = customGetTypeValue;\r\n    if (this.customGetTypeValue !== undefined && !isFunction(this.customGetTypeValue)) {\r\n      throw new Error('\"customGetTypeValue\" must be a callable object, i.e. function.');\r\n    }\r\n  }\r\n\r\n  getTypeValue(value) {\r\n    if (this.customGetTypeValue) {\r\n      return this.customGetTypeValue(value);\r\n    }\r\n\r\n    return super.getTypeValue(value);\r\n  }\r\n\r\n  findIndexedType(target) {\r\n    const { length } = target;\r\n\r\n    for (let index = 0; index < length; index += 1) {\r\n      const type = this.getTypeValue(target[index]);\r\n\r\n      if (type) {\r\n        return type;\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  init(target, cachedStorage = null) {\r\n    if (\r\n      !cachedStorage &&\r\n      this.collectTypesOnInit &&\r\n      this.areArrayElementsOfSameType &&\r\n      isIndexAccessTarget(target)\r\n    ) {\r\n      const storage = createTypesStorage();\r\n      const type = this.findIndexedType(target);\r\n\r\n      if (type) {\r\n        storage.add(INDEX, type);\r\n        return storage;\r\n      }\r\n    }\r\n\r\n    return super.init(target, cachedStorage);\r\n  }\r\n\r\n  getProperty(target, names, value, storage) {\r\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\r\n      return this.getIndexProperty(target, names, value, storage);\r\n    }\r\n\r\n    return this.getNamedProperty(target, names, value, storage);\r\n  }\r\n\r\n  getIndexProperty(target, names, value, storage) {\r\n    return this.checkType(\r\n      GET_PROPERTY,\r\n      target,\r\n      names.clone(INDEX),\r\n      this.getTypeValue(value),\r\n      storage,\r\n    );\r\n  }\r\n\r\n  getNamedProperty(target, names, value, storage) {\r\n    return super.getProperty(target, names, value, storage);\r\n  }\r\n\r\n  setProperty(target, names, newValue, storage) {\r\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\r\n      return this.setIndexProperty(target, names, newValue, storage);\r\n    }\r\n\r\n    return this.setNamedProperty(target, names, newValue, storage);\r\n  }\r\n\r\n  setIndexProperty(target, names, newValue, storage) {\r\n    const type = this.getTypeValue(newValue);\r\n\r\n    return this.checkType(SET_PROPERTY, target, names, type, storage);\r\n  }\r\n\r\n  setNamedProperty = (target, names, newValue, storage) => {\r\n    return super.setProperty(target, names, newValue, storage);\r\n  };\r\n}\r\n\r\nexport const createExtendedTypeChecker = (\r\n  collectTypesOnInit = true,\r\n  enableGetChecker = true,\r\n  areArrayElementsOfSameType = true,\r\n) => new ExtendedTypeChecker(collectTypesOnInit, enableGetChecker, areArrayElementsOfSameType);\r\n\r\nexport default ExtendedTypeChecker;\r\n"],"names":["Object","defineProperty","exports","value","constructErrorString","action","name","required","received","requiredTypeString","actualTypeString","console","error","warn","receivedTypeString","Error","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","MapOfSets","[object Object]","this","storage","Map","key","values","get","size","Array","from","callback","forEach","add","set","Set","remove","delete","_interopDefault","ex","require$$0","require$$1","REPORT_NEVER","REPORT_ONCE","REPORT_ALL","REPORT_KEY","Symbol","PROPERTY_REPORT_KEY","globalReportingLevel","validateReportingLevel","level","getGlobalReportingLevel","getTargetReportingLevel","getReportingLevel","constructor","defaultMergeStrategy","source","type","TypeInfoStorage","super","types","mergeStrategy","generalLevel","perPropertyLevels","setTargetGeneralReportingLevel","keys","reduce","levels","prop","setTargetPropertyReportingLevel","errorReporter","typeCheckerSimpleReporting","ConsoleErrorReporter","getErrorReporter","MERGE","GET_PROPERTY","SET_PROPERTY","ARGUMENTS","RETURN_VALUE","checkPrimitiveType","names","lastName","missingType","hasValue","toString","list","join","addFor","getTypeValue","undefined","PrimitiveTypeChecker","collectTypesOnInit","enableGetChecker","cachedStorage","typeCheckerLevelsStorage","createTypesStorage","sourceStorage","copyTo","targetFirstValue","next","sourceType","checkType","args","length","valid","index","clone","callNames","appendCustomValue","setGlobalReportingLevel","setReportingLevel","getClass","proto","getPrototypeOf","match","String","def","defaultValue","valueFormatter","getDefault","newValue","defaults","defaultValues","copy","AsIs","asIs","valueOf","toPrimitive","appendPathNameToString","str","string","parseInt","test","PathSequence","customString","nextName","sequence","append","isFunction","withProxy","handlers","apply","construct","functionHandlers","Proxy","require$$2","getDefaultTypeChecker","setDefaultTypeChecker","closureValue","singleValueFactory","isEnabled","setEnabled","constructors","addIgnoredClasses","classes","isValueOfIgnoredClass","Date","getDefaultWrapConfig","setWrapConfigValue","valuesMapFactory","getWrapConfigValue","getChildInfoKey","ChildrenCache","children","cache","childInfo","sourceCache","createChildrenCache","INFO_KEY","getTargetInfo","setTargetInfo","info","TargetInfo","checker","data","deep","pathSequenceToString","createPathSequence","child","store","init","createChildWithNames","mergeConfigs","TARGET_KEY","isSymbol","isWrapped","isWrappable","isOfWrappableType","getPropertyFactory","wrapFn","nextNames","getProperty","isIgnoredProperty","getChild","getTargetProperty","updateTargetInfo","setPropertyFactory","setProperty","setTargetProperty","setNonTargetProperty","getTypeCheckedChild","createChild","getTargetArguments","argumentsList","createInfoFromOptions","createTargetInfo","generateHandlers","create","config","thisArg","arguments","result","returnValue","applyFunctionFactory","Target","constructFactory","deleteProperty","deletePropertyFactory","createWrapFactory","proxyConfig","wrapInternal","assignInfoAndWrap","wrap","options","deepInitializer","findWrapped","find","merge","sources","wrapped","assign","indexBasedClasses","INDEX","isIndexAccessTarget","setIndexValueType","getTypeCheckerData","ExtendedTypeChecker","areArrayElementsOfSameType","customGetTypeValue","setNamedProperty","findIndexedType","getIndexProperty","getNamedProperty","setIndexProperty"],"mappings":"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"}