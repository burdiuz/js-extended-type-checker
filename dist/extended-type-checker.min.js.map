{"version":3,"file":"extended-type-checker.min.js","sources":["../../js-primitive-type-checker/node_modules/@actualwave/hasOwn/hasOwn.js","../../js-primitive-type-checker/dist/primitive-type-checker.js","../../js-type-checkers/node_modules/@actualwave/hasOwn/hasOwn.js","../../js-type-checkers/dist/type-checkers.js","../source/indexed.js","../source/replace.js","../source/index.js","../source/minified.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/hasOwn'));\n\nconst MERGE = '(Merge)';\nconst GET_PROPERTY = '(GetProperty)';\nconst SET_PROPERTY = '(SetProperty)';\nconst ARGUMENTS = '(Arguments)';\nconst RETURN_VALUE = '(ReturnValue)';\n\nfunction AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\nconst buildPath = sequence => sequence.reduce((str, name) => {\n  if (name instanceof AsIs) {\n    return `${str}${name}`;\n  } else if (String(parseInt(name, 10)) === name) {\n    return `${str}[${name}]`;\n  } else if (/^[a-z][\\w$]*$/i.test(name)) {\n    return str ? `${str}.${name}` : name;\n  }\n\n  return `${str}[\"${name}\"]`;\n}, '');\n\nconst checkPrimitiveType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst mergeConfigs = ({ types, errorReporter }, source, names = []) => {\n  const sourceTypes = source.types;\n\n  for (const name in sourceTypes) {\n    if (hasOwn(sourceTypes, name)) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n\n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(MERGE, buildPath([...names, name]), targetType, sourceType);\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  }\n\n  return { types, errorReporter };\n};\n\nconst getTypeString = value => {\n  if (value === undefined) {\n    return '';\n  } else if (value instanceof Array) {\n    return 'array';\n  }\n\n  return typeof value;\n};\n\nconst propertyCheckerFactory = action => {\n  function checkValueType(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(action, types, name, type, errorReporter, sequence);\n  }\n\n  return checkValueType;\n};\n\nconst getPropertyChecker = propertyCheckerFactory(GET_PROPERTY);\nconst setPropertyChecker = propertyCheckerFactory(SET_PROPERTY);\n\nclass PrimitiveTypeChecker {\n  constructor() {\n    this.collectTypesOnInit = true;\n    this.getTypeString = getTypeString;\n    this.mergeConfigs = mergeConfigs;\n  }\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target).forEach(key => {\n        types[key] = getTypeString(target[key]);\n      });\n    }\n\n    return {\n      types,\n      errorReporter\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    return getPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, value, config, sequence) {\n    return setPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(ARGUMENTS, types, String(index), type, errorReporter, sequence);\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(RETURN_VALUE, types, AsIs(RETURN_VALUE), type, errorReporter, sequence);\n  }\n}\n\nexports.MERGE = MERGE;\nexports.ARGUMENTS = ARGUMENTS;\nexports.GET_PROPERTY = GET_PROPERTY;\nexports.RETURN_VALUE = RETURN_VALUE;\nexports.SET_PROPERTY = SET_PROPERTY;\nexports.buildPath = buildPath;\nexports.AsIs = AsIs;\nexports.checkPrimitiveType = checkPrimitiveType;\nexports.mergeConfigs = mergeConfigs;\nexports.getTypeString = getTypeString;\nexports.propertyCheckerFactory = propertyCheckerFactory;\nexports.PrimitiveTypeChecker = PrimitiveTypeChecker;\nexports.default = PrimitiveTypeChecker;\n//# sourceMappingURL=primitive-type-checker.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/hasOwn'));\n\nlet defaultTypeChecker = null;\n\nconst getDefaultTypeChecker = () => defaultTypeChecker;\nconst setDefaultTypeChecker = typeChecker => {\n  defaultTypeChecker = typeChecker;\n};\n\nconst PROXY_WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nconst PROXY_WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nconst PROXY_WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nconst PROXY_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst getDefaultProxyConfig = () => ({\n  [PROXY_WRAP_FUNCTION_RETURN_VALUES]: true,\n  [PROXY_WRAP_FUNCTION_ARGUMENTS]: false,\n  [PROXY_WRAP_SET_PROPERTY_VALUES]: true,\n  [PROXY_IGNORE_PROTOTYPE_METHODS]: false\n});\n\nconst config = getDefaultProxyConfig();\n\nconst setProxyConfig = newConfig => Object.assign(config, newConfig);\n\nconst getProxyConfig = () => Object.assign({}, config);\n\nconst getProxyConfigValue = (key, info = null) => hasOwn(info, key) ? info[key] : config[key];\n\nconst constructErrorString = (action, name, required, actual) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${actual}\"`;\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, actualTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n};\n\nlet errorReporter = ConsoleErrorReporter;\n\nconst getErrorReporter = () => errorReporter;\n\nconst setErrorReporter = reporter => {\n  errorReporter = reporter;\n};\n\nlet enabled = true;\n\nconst isEnabled = () => enabled;\nconst setEnabled = (value = true) => {\n  enabled = !!value;\n};\n\nconst INFO_KEY = Symbol('type-checkers::info');\n\nconst createChildrenCache = (children = {}) => Object.assign({}, children);\n\nconst createTargetInfo = (checker, config, deep = true, names = [], children = createChildrenCache()) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children\n});\n\nconst getTargetInfo = target => target ? target[INFO_KEY] : undefined;\n\nconst setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nconst hasTargetInfo = target => !!getTargetInfo(target);\n\nconst getTargetTypeChecker = target => target && target[INFO_KEY] ? target[INFO_KEY].checker : undefined;\n\nconst getTargetTypeCheckerConfig = target => {\n  if (!target || !target[INFO_KEY]) {\n    return undefined;\n  }\n\n  return target[INFO_KEY].config;\n};\n\nconst mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const name in sourceCache) {\n    if (hasOwn(targetCache, name)) {\n      targetCache[name] = mergeTargetInfo(targetCache[name], sourceCache[name]);\n    } else {\n      targetCache[name] = sourceCache[name];\n    }\n  }\n\n  return targetCache;\n};\n\nconst storeChildInfo = (cache, name, childInfo) => {\n  delete cache[name];\n\n  if (childInfo) {\n    cache[name] = childInfo;\n  }\n};\n\nconst storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nconst getChildInfo = (cache, name) => cache[name];\n\nconst mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n\nconst TARGET_KEY = Symbol('type-checkers::target');\n\nconst getOriginalTarget = target => {\n  return target[TARGET_KEY] || target;\n};\n\nconst validTypes = {\n  object: true,\n  function: true\n};\n\nconst isValidTarget = target => Boolean(target && validTypes[typeof target]);\nconst isTypeChecked = target => Boolean(target && target[TARGET_KEY]);\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (value instanceof Function && !hasOwn(target, property) && getProxyConfigValue(PROXY_IGNORE_PROTOTYPE_METHODS, info)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getProperty = createFn => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (!isValidTarget(value) || isTypeChecked(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    const { names, config, checker } = getTargetInfo(target);\n\n    if (checker.setProperty) {\n      checker.setProperty(target, property, value, config, names);\n    }\n\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, checker, config, children } = info;\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_SET_PROPERTY_VALUES, info)) {\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = createFn => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  return setNonTargetProperty(target, property, value) || setTargetProperty(createFn, target, property, value);\n};\n\nconst getTypeCheckedChild = (createFn, info, name, value) => {\n  if (!isValidTarget(value)) {\n    return value;\n  }\n\n  let result = value;\n\n  if (!isTypeChecked(value)) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      result = createFn(value, { info: childInfo });\n    } else {\n      const { deep, names, checker } = info;\n      result = createFn(value, { deep, names: [...names, name], checker });\n      storeChildInfoFrom(children, name, result);\n    }\n  }\n\n  return result;\n};\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  const info = getTargetInfo(target);\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(createFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst callFunction = createFn => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(createFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nlet getProperty$1;\nlet setProperty$1;\nlet callFunction$1;\n\nconst objectProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1\n});\n\nconst functionProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1,\n  apply: callFunction$1,\n  construct: callFunction$1\n});\n\nconst wrapWithProxy = target => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nconst createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(checker, checker.init(target, getErrorReporter(), config), deep, names, createChildrenCache(children));\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(target, createInfoFromOptions(target, options));\n\n  return wrapWithProxy(target);\n};\n\ngetProperty$1 = getProperty(create);\nsetProperty$1 = setProperty(create);\ncallFunction$1 = callFunction(create);\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target).forEach(name => {\n    const value = target[name];\n\n    checker.getProperty(target, name, value, config, names);\n\n    // skip functions/methods since we get info about them only when being executed\n    if (typeof value === 'object') {\n      let childInfo = getChildInfo(children, name);\n\n      if (childInfo) {\n        deepInitializer(value, { info: childInfo });\n      } else {\n        childInfo = deepInitializer(value, { deep, names: [...names, name], checker });\n        storeChildInfo(children, name, childInfo);\n      }\n    }\n  });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nconst objectMerge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find(item => hasTargetInfo(item))),\n        deep: false\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\n// TODO if enabled, replaces original value with type checked\nconst properties = (target, options = undefined, ...names) => {\n  if (!isEnabled()) {\n    return target;\n  }\n\n  if (!isValidTarget(target)) {\n    throw new Error('Target must be a valid object.');\n  }\n\n  if (Object.isFrozen(target) || Object.isSealed(target)) {\n    throw new Error('Target object should not be sealed or frozen.');\n  }\n\n  if (!names.length) {\n    // Symbols and non-enumerables must be explicitly specified\n    names = Object.keys(target);\n  }\n\n  const { length } = names;\n  for (let index = 0; index < length; index += 1) {\n    const name = names[index];\n    const { writable, get, set } = Object.getOwnPropertyDescriptor(target, name);\n\n    // Prohibit applying to properties with accessor/mutator pair?\n    if (get && set || writable) {\n      const value = target[name];\n\n      if (isValidTarget(value) && !isTypeChecked(value)) {\n        target[name] = create(value, options);\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.getDefaultTypeChecker = getDefaultTypeChecker;\nexports.setDefaultTypeChecker = setDefaultTypeChecker;\nexports.PROXY_WRAP_FUNCTION_RETURN_VALUES = PROXY_WRAP_FUNCTION_RETURN_VALUES;\nexports.PROXY_WRAP_FUNCTION_ARGUMENTS = PROXY_WRAP_FUNCTION_ARGUMENTS;\nexports.PROXY_WRAP_SET_PROPERTY_VALUES = PROXY_WRAP_SET_PROPERTY_VALUES;\nexports.PROXY_IGNORE_PROTOTYPE_METHODS = PROXY_IGNORE_PROTOTYPE_METHODS;\nexports.getDefaultProxyConfig = getDefaultProxyConfig;\nexports.setProxyConfig = setProxyConfig;\nexports.getProxyConfig = getProxyConfig;\nexports.create = create;\nexports.createDeep = createDeep;\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\nexports.getErrorReporter = getErrorReporter;\nexports.setErrorReporter = setErrorReporter;\nexports.isEnabled = isEnabled;\nexports.setEnabled = setEnabled;\nexports.getTargetInfo = getTargetInfo;\nexports.setTargetInfo = setTargetInfo;\nexports.hasTargetInfo = hasTargetInfo;\nexports.getTargetTypeChecker = getTargetTypeChecker;\nexports.getTargetTypeCheckerConfig = getTargetTypeCheckerConfig;\nexports.mergeTargetInfo = mergeTargetInfo;\nexports.getOriginalTarget = getOriginalTarget;\nexports.merge = objectMerge;\nexports.properties = properties;\nexports.isTypeChecked = isTypeChecked;\nexports.isValidTarget = isValidTarget;\nexports.default = create;\n//# sourceMappingURL=type-checkers.js.map\n","import {\n  getTargetTypeChecker,\n  getTargetTypeCheckerConfig,\n} from '@actualwave/type-checkers';\n\nconst indexBasedClasses = [Array];\n\nexport const INDEX = '(Index)';\n\nexport const isIndexAccessTarget = (target) =>\n  target && indexBasedClasses.indexOf(target.constructor) >= 0;\n\nexport const registerIndexBasedClass = (constructor) => {\n  indexBasedClasses.push(constructor);\n};\n\nexport const setIndexValueType = (target, type) => {\n  const config = getTargetTypeCheckerConfig(target);\n\n  if (config) {\n    config.types[INDEX] = type || '';\n  }\n};\n\nexport const setIndexValueTypeBy = (target, value) => {\n  setIndexValueType(target, getTargetTypeChecker(target).getTypeString(value));\n};\n","import { ARGUMENTS, RETURN_VALUE } from '@actualwave/primitive-type-checker';\n\nimport { getTargetTypeCheckerConfig } from '@actualwave/type-checkers';\n\nimport { INDEX } from './indexed';\n\nexport const replacePropertyTypeCheck = (target, name, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[name];\n\n  if (fn) {\n    types[name] = fn;\n  }\n};\n\nexport const replaceArgumentsTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[ARGUMENTS];\n\n  if (fn) {\n    types[ARGUMENTS] = fn;\n  }\n};\n\nexport const replaceReturnValueTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[RETURN_VALUE];\n\n  if (fn) {\n    types[RETURN_VALUE] = fn;\n  }\n};\n\nexport const replaceIndexedTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[INDEX];\n\n  if (fn) {\n    types[INDEX] = fn;\n  }\n};\n","import PrimitiveTypeChecker, {\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  AsIs,\n  checkPrimitiveType,\n} from '@actualwave/primitive-type-checker';\n\nimport {\n  INDEX,\n  isIndexAccessTarget,\n  registerIndexBasedClass,\n  setIndexValueType,\n  setIndexValueTypeBy,\n} from './indexed';\n\nimport {\n  replaceArgumentsTypeCheck,\n  replaceIndexedTypeCheck,\n  replacePropertyTypeCheck,\n  replaceReturnValueTypeCheck,\n} from './replace';\n\nclass ExtendedTypeChecker extends PrimitiveTypeChecker {\n  areArrayElementsOfSameType = true;\n  replacePropertyTypeCheck = replacePropertyTypeCheck;\n  replaceArgumentsTypeCheck = replaceArgumentsTypeCheck;\n  replaceReturnValueTypeCheck = replaceReturnValueTypeCheck;\n  replaceIndexedTypeCheck = replaceIndexedTypeCheck;\n  isIndexAccessTarget = isIndexAccessTarget;\n  registerIndexBasedClass = registerIndexBasedClass;\n  setIndexValueType = setIndexValueType;\n  setIndexValueTypeBy = setIndexValueTypeBy;\n\n  init(target, errorReporter, cachedTypes = null) {\n    const types = {};\n\n    if (\n      !cachedTypes &&\n      this.collectTypesOnInit &&\n      this.areArrayElementsOfSameType &&\n      isIndexAccessTarget(target)\n    ) {\n      const { length } = target;\n\n      for (let index = 0; index < length; index += 1) {\n        const type = this.getTypeString(target[index]);\n\n        if (type) {\n          types[INDEX] = type;\n          break;\n        }\n      }\n    } else {\n      return super.init(target, errorReporter, cachedTypes);\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.getIndexProperty(target, INDEX, value, config, sequence);\n    }\n\n    return this.getNamedProperty(target, name, value, config, sequence);\n  }\n\n  getIndexProperty(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      GET_PROPERTY,\n      types,\n      AsIs(INDEX),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  getNamedProperty(target, name, value, config, sequence) {\n    const typeFn = config.types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    return super.getProperty(target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, newValue, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.setIndexProperty(target, INDEX, newValue, config, sequence);\n    }\n\n    return this.setNamedProperty(target, name, newValue, config, sequence);\n  }\n\n  setIndexProperty(target, name, newValue, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    const type = this.getTypeString(newValue);\n\n    return checkPrimitiveType(\n      SET_PROPERTY,\n      types,\n      AsIs(INDEX),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  setNamedProperty(target, name, newValue, config, sequence) {\n    const typeFn = config.types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    return super.setProperty(target, name, newValue, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const typeFn = config.types[ARGUMENTS];\n\n    if (typeFn instanceof Function) {\n      return typeFn(ARGUMENTS, target, args, config, sequence);\n    }\n\n    return super.arguments(target, thisArg, args, config, sequence);\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const typeFn = config.types[RETURN_VALUE];\n\n    if (typeFn instanceof Function) {\n      return typeFn(RETURN_VALUE, target, value, config, sequence);\n    }\n\n    return super.returnValue(target, thisArg, value, config, sequence);\n  }\n}\n\nexport {\n  isIndexAccessTarget,\n  registerIndexBasedClass,\n  setIndexValueType,\n  setIndexValueTypeBy,\n  replaceArgumentsTypeCheck,\n  replaceIndexedTypeCheck,\n  replacePropertyTypeCheck,\n  replaceReturnValueTypeCheck,\n  ExtendedTypeChecker,\n};\n\nexport default ExtendedTypeChecker;\n","const primitive = require('@actualwave/primitive-type-checker');\nconst typeCheckers = require('@actualwave/type-checkers');\nconst extended = require('./index');\n\ntypeCheckers.setDefaultTypeChecker(new extended.ExtendedTypeChecker());\n\nObject.assign(exports, primitive, extended, typeCheckers);\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","ex","require","ARGUMENTS","RETURN_VALUE","AsIs","this","asIs","toString","valueOf","Symbol","toPrimitive","buildPath","sequence","reduce","str","name","String","parseInt","test","checkPrimitiveType","action","types","type","errorReporter","storedType","mergeConfigs","source","names","sourceTypes","sourceType","targetType","getTypeString","undefined","Array","propertyCheckerFactory","config","getPropertyChecker","setPropertyChecker","PrimitiveTypeChecker","collectTypesOnInit","cachedTypes","keys","forEach","key","thisArg","args","length","valid","index","defaultTypeChecker","getDefaultTypeChecker","getDefaultProxyConfig","getProxyConfigValue","info","constructErrorString","required","actual","ConsoleErrorReporter","requiredTypeString","actualTypeString","console","error","getErrorReporter","enabled","isEnabled","INFO_KEY","createChildrenCache","children","assign","getTargetInfo","setTargetInfo","hasTargetInfo","storeChildInfo","cache","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","targetCache","sourceCache","mergeChildrenCache","TARGET_KEY","validTypes","isValidTarget","isTypeChecked","getTypeCheckedChild","createFn","result","getProperty$1","setProperty$1","callFunction$1","wrapWithProxy","Function","Proxy","functionProxy","objectProxy","createInfoFromOptions","createTargetInfo","init","create","options","getProperty","isIgnoredProperty","getTargetProperty","Error","setProperty","setNonTargetProperty","setTargetProperty","argumentsList","arguments","getTargetArguments","apply","returnValue","callFunction","deepInitializer","typeChecker","newConfig","warn","reporter","sources","find","item","isFrozen","isSealed","writable","get","set","getOwnPropertyDescriptor","indexBasedClasses","INDEX","isIndexAccessTarget","indexOf","constructor","registerIndexBasedClass","push","setIndexValueType","getTargetTypeCheckerConfig","setIndexValueTypeBy","getTargetTypeChecker","replacePropertyTypeCheck","fn","replaceArgumentsTypeCheck","replaceReturnValueTypeCheck","replaceIndexedTypeCheck","ExtendedTypeChecker","areArrayElementsOfSameType","super","getIndexProperty","getNamedProperty","typeFn","GET_PROPERTY","newValue","setIndexProperty","setNamedProperty","SET_PROPERTY","typeCheckers","setDefaultTypeChecker","extended","primitive"],"mappings":"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"}