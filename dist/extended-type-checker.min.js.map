{"version":3,"file":"extended-type-checker.min.js","sources":["../node_modules/@actualwave/has-own/has-own.js","../node_modules/@actualwave/primitive-type-checker/dist/primitive-type-checker.js","../node_modules/@actualwave/type-checkers/dist/type-checkers.js","../source/indexed.js","../source/replace.js","../source/index.js","../source/minified.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\n\nconst MERGE = '(Merge)';\nconst GET_PROPERTY = '(GetProperty)';\nconst SET_PROPERTY = '(SetProperty)';\nconst ARGUMENTS = '(Arguments)';\nconst RETURN_VALUE = '(ReturnValue)';\n\nfunction AsIs(value) {\n  if (this instanceof AsIs) {\n    this.value = value;\n  } else {\n    return new AsIs(value);\n  }\n}\n\nfunction asIs() {\n  return this.value;\n}\n\nAsIs.prototype.toString = asIs;\nAsIs.prototype.valueOf = asIs;\nAsIs.prototype[Symbol.toPrimitive] = asIs;\n\nconst buildPath = sequence => sequence.reduce((str, name) => {\n  if (name instanceof AsIs) {\n    return `${str}${name}`;\n  } else if (String(parseInt(name, 10)) === name) {\n    return `${str}[${name}]`;\n  } else if (/^[a-z][\\w$]*$/i.test(name)) {\n    return str ? `${str}.${name}` : name;\n  }\n\n  return `${str}[\"${name}\"]`;\n}, '');\n\nconst checkPrimitiveType = (action, types, name, type, errorReporter, sequence) => {\n  if (!type) {\n    return true;\n  }\n\n  const storedType = types[name];\n\n  if (storedType) {\n    if (storedType !== type) {\n      errorReporter(action, buildPath([...sequence, name]), storedType, type);\n\n      return false;\n    }\n  } else {\n    types[name] = type;\n  }\n\n  return true;\n};\n\nconst mergeConfigs = ({ types, errorReporter }, source, names = []) => {\n  const sourceTypes = source.types;\n\n  for (const name in sourceTypes) {\n    if (hasOwn(sourceTypes, name)) {\n      const sourceType = sourceTypes[name];\n      const targetType = types[name];\n\n      if (sourceType && targetType && targetType !== sourceType) {\n        errorReporter(MERGE, buildPath([...names, name]), targetType, sourceType);\n      } else {\n        types[name] = sourceType;\n      }\n    }\n  }\n\n  return { types, errorReporter };\n};\n\nconst getTypeString = value => {\n  if (value === undefined) {\n    return '';\n  } else if (value instanceof Array) {\n    return 'array';\n  }\n\n  return typeof value;\n};\n\nconst propertyCheckerFactory = action => {\n  function checkValueType(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(action, types, name, type, errorReporter, sequence);\n  }\n\n  return checkValueType;\n};\n\nconst getPropertyChecker = propertyCheckerFactory(GET_PROPERTY);\nconst setPropertyChecker = propertyCheckerFactory(SET_PROPERTY);\n\nclass PrimitiveTypeChecker {\n  constructor() {\n    this.collectTypesOnInit = true;\n    this.getTypeString = getTypeString;\n    this.mergeConfigs = mergeConfigs;\n  }\n\n  init(target, errorReporter, cachedTypes = null) {\n    let types = {};\n\n    if (cachedTypes) {\n      types = cachedTypes;\n    } else if (this.collectTypesOnInit) {\n      Object.keys(target).forEach(key => {\n        types[key] = getTypeString(target[key]);\n      });\n    }\n\n    return {\n      types,\n      errorReporter\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    return getPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, value, config, sequence) {\n    return setPropertyChecker.call(this, target, name, value, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const { types, errorReporter } = config;\n\n    const { length } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeString(args[index]);\n      const agrValid = checkPrimitiveType(ARGUMENTS, types, String(index), type, errorReporter, sequence);\n\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(RETURN_VALUE, types, AsIs(RETURN_VALUE), type, errorReporter, sequence);\n  }\n}\n\nexports.MERGE = MERGE;\nexports.ARGUMENTS = ARGUMENTS;\nexports.GET_PROPERTY = GET_PROPERTY;\nexports.RETURN_VALUE = RETURN_VALUE;\nexports.SET_PROPERTY = SET_PROPERTY;\nexports.buildPath = buildPath;\nexports.AsIs = AsIs;\nexports.checkPrimitiveType = checkPrimitiveType;\nexports.mergeConfigs = mergeConfigs;\nexports.getTypeString = getTypeString;\nexports.propertyCheckerFactory = propertyCheckerFactory;\nexports.PrimitiveTypeChecker = PrimitiveTypeChecker;\nexports.default = PrimitiveTypeChecker;\n//# sourceMappingURL=primitive-type-checker.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\n\nlet defaultTypeChecker = null;\n\nconst getDefaultTypeChecker = () => defaultTypeChecker;\nconst setDefaultTypeChecker = typeChecker => {\n  defaultTypeChecker = typeChecker;\n};\n\nconst PROXY_WRAP_FUNCTION_RETURN_VALUES = 'wrapFunctionReturnValues';\nconst PROXY_WRAP_FUNCTION_ARGUMENTS = 'wrapFunctionArguments';\nconst PROXY_WRAP_SET_PROPERTY_VALUES = 'wrapSetPropertyValues';\nconst PROXY_IGNORE_PROTOTYPE_METHODS = 'ignorePrototypeMethods';\n\nconst getDefaultProxyConfig = () => ({\n  [PROXY_WRAP_FUNCTION_RETURN_VALUES]: true,\n  [PROXY_WRAP_FUNCTION_ARGUMENTS]: false,\n  [PROXY_WRAP_SET_PROPERTY_VALUES]: true,\n  [PROXY_IGNORE_PROTOTYPE_METHODS]: false\n});\n\nconst config = getDefaultProxyConfig();\n\nconst setProxyConfig = newConfig => Object.assign(config, newConfig);\n\nconst getProxyConfig = () => Object.assign({}, config);\n\nconst getProxyConfigValue = (key, info = null) => hasOwn(info, key) ? info[key] : config[key];\n\n/* eslint-disable import/prefer-default-export */\n\nconst constructErrorString = (action, name, required, received) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${received}\"`;\n\n/* eslint-disable no-console */\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\n/* eslint-disable import/prefer-default-export */\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, receivedTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, receivedTypeString));\n};\n\nlet errorReporter = ConsoleErrorReporter;\n\nconst getErrorReporter = () => errorReporter;\n\nconst setErrorReporter = reporter => {\n  errorReporter = reporter;\n};\n\nlet enabled = true;\n\nconst isEnabled = () => enabled;\nconst setEnabled = (value = true) => {\n  enabled = !!value;\n};\n\nconst INFO_KEY = Symbol('type-checkers::info');\n\nconst createChildrenCache = (children = {}) => Object.assign({}, children);\n\nconst createTargetInfo = (checker, config, deep = true, names = [], children = createChildrenCache()) => ({\n  checker,\n  config,\n  deep,\n  names,\n  children\n});\n\nconst getTargetInfo = target => target ? target[INFO_KEY] : undefined;\n\nconst setTargetInfo = (target, info) => {\n  if (target && info) {\n    target[INFO_KEY] = info;\n  }\n};\n\nconst hasTargetInfo = target => !!getTargetInfo(target);\n\n// TODO three times getting same, might need optimizing\nconst getTargetTypeChecker = target => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return info && info.checker || undefined;\n  }\n\n  return undefined;\n};\n\nconst getTargetTypeCheckerConfig = target => {\n  if (target) {\n    const info = target[INFO_KEY];\n\n    return info && info.config || undefined;\n  }\n\n  return undefined;\n};\n\n/*\n  I have had to apply custom key instead of name as is to\n  fix \"construtor\" issue. Since ordinary object has some\n  properties with values from start, these properties were\n  mustakenly returned as child info objects, for example, if\n  requesting hild info for \"constructor\" function of the target,\n  it returned class constructor which caused errors later,\n  when accesing info properties.\n */\nconst getChildInfoKey = name => `@${name}`;\n\nconst mergeChildrenCache = (targetCache, sourceCache) => {\n  for (const key in sourceCache) {\n    if (hasOwn(targetCache, key)) {\n      // eslint-disable-next-line no-use-before-define\n      targetCache[key] = mergeTargetInfo(targetCache[key], sourceCache[key]);\n    } else {\n      targetCache[key] = sourceCache[key];\n    }\n  }\n\n  return targetCache;\n};\n\nconst storeChildInfo = (cache, name, childInfo) => {\n  const key = getChildInfoKey(name);\n  delete cache[key];\n\n  if (childInfo) {\n    cache[key] = childInfo;\n  }\n};\n\nconst storeChildInfoFrom = (cache, name, child) => {\n  storeChildInfo(cache, name, getTargetInfo(child));\n};\n\nconst getChildInfo = (cache, name) => cache[getChildInfoKey(name)];\n\nconst mergeTargetInfo = (targetInfo, sourceInfo) => {\n  const { deep, checker, children, config, names } = targetInfo;\n\n  if (checker === sourceInfo.checker) {\n    targetInfo.deep = deep || sourceInfo.deep;\n    targetInfo.children = mergeChildrenCache(children, sourceInfo.children);\n    targetInfo.config = checker.mergeConfigs(config, sourceInfo.config, names);\n  } else {\n    console.error('TypeChecked objects can be merged only if using exactly same instance of type checker.');\n  }\n\n  return targetInfo;\n};\n\nconst TARGET_KEY = Symbol('type-checkers::target');\n\nconst getOriginalTarget = target => target && target[TARGET_KEY] || target;\n\nconst validTypes = {\n  object: true,\n  function: true\n};\n\nconst isValidTarget = target => Boolean(target && validTypes[typeof target]);\nconst isTypeChecked = target => Boolean(target && target[TARGET_KEY]);\n\nconst getTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, children, names, checker } = info;\n\n  if (deep || value instanceof Function) {\n    const childInfo = getChildInfo(children, property);\n\n    if (childInfo) {\n      value = createFn(value, { info: childInfo });\n    } else {\n      value = createFn(value, { deep, names: [...names, property], checker });\n      storeChildInfoFrom(children, property, value);\n    }\n  }\n\n  return value;\n};\n\nconst isIgnoredProperty = (target, info, property, value) => {\n  if (value instanceof Function && !hasOwn(target, property) && getProxyConfigValue(PROXY_IGNORE_PROTOTYPE_METHODS, info)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst getProperty = createFn => (target, property) => {\n  const value = target[property];\n\n  if (property === INFO_KEY) {\n    return value;\n    /*\n    target[TARGET_KEY] is a virtual property accessing which indicates\n    if object is wrapped with type checked proxy or not.\n    */\n  } else if (property === TARGET_KEY) {\n    return target;\n  }\n\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.getProperty) {\n    checker.getProperty(target, property, value, config, names);\n  }\n\n  if (!isValidTarget(value) || isTypeChecked(value) || isIgnoredProperty(target, info, property, value)) {\n    return value;\n  }\n\n  return getTargetProperty(createFn, target, property, value);\n};\n\nconst setNonTargetProperty = (target, property, value) => {\n  if (property === INFO_KEY) {\n    let info = getTargetInfo(target);\n    if (info && value && info !== value) {\n      info = mergeTargetInfo(info, value);\n    } else {\n      info = value;\n    }\n\n    target[property] = info;\n    return true;\n  } else if (!isValidTarget(value)) {\n    const { names, config, checker } = getTargetInfo(target);\n\n    if (checker.setProperty) {\n      checker.setProperty(target, property, value, config, names);\n    }\n\n    target[property] = value;\n    return true;\n  }\n\n  return false;\n};\n\nconst setTargetProperty = (createFn, target, property, value) => {\n  const info = getTargetInfo(target);\n  const { deep, names, checker, config, children } = info;\n\n  if (checker.setProperty) {\n    checker.setProperty(target, property, value, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_SET_PROPERTY_VALUES, info)) {\n    if (!isTypeChecked(value)) {\n      const childInfo = getChildInfo(children, property);\n\n      if (childInfo) {\n        value = createFn(value, { info: childInfo });\n      } else {\n        value = createFn(value, { deep, names: [...names, property], checker });\n      }\n    }\n\n    storeChildInfoFrom(children, property, value);\n  }\n\n  target[property] = value;\n  return true;\n};\n\nconst setProperty = createFn => (target, property, value) => {\n  if (property === TARGET_KEY) {\n    throw new Error(`\"${TARGET_KEY}\" is a virtual property and cannot be set`);\n  }\n\n  return setNonTargetProperty(target, property, value) || setTargetProperty(createFn, target, property, value);\n};\n\n/* eslint-disable import/prefer-default-export */\n\nconst getTypeCheckedChild = (createFn, info, name, value) => {\n  if (!isValidTarget(value)) {\n    return value;\n  }\n\n  let result = value;\n\n  if (!isTypeChecked(value)) {\n    const { children } = info;\n    const childInfo = getChildInfo(children, name);\n\n    if (childInfo) {\n      result = createFn(value, { info: childInfo });\n    } else {\n      const { deep, names, checker } = info;\n      result = createFn(value, { deep, names: [...names, name], checker });\n      storeChildInfoFrom(children, name, result);\n    }\n  }\n\n  return result;\n};\n\nconst getTargetArguments = (createFn, target, argumentsList) => {\n  const info = getTargetInfo(target);\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_ARGUMENTS, info)) {\n    const { length } = argumentsList;\n    // FIXME cache arguments info objects as children\n    for (let index = 0; index < length; index++) {\n      argumentsList[index] = getTypeCheckedChild(createFn, info, String(index), argumentsList[index]);\n    }\n  }\n\n  return argumentsList;\n};\n\nconst callFunction = createFn => (target, thisArg, argumentsList) => {\n  const info = getTargetInfo(target);\n  const { names, config, checker } = info;\n\n  if (checker.arguments) {\n    checker.arguments(target, thisArg, argumentsList, config, names);\n  }\n\n  argumentsList = getTargetArguments(createFn, target, argumentsList);\n\n  let result = target.apply(thisArg, argumentsList);\n\n  if (checker.returnValue) {\n    checker.returnValue(target, thisArg, result, config, names);\n  }\n\n  if (getProxyConfigValue(PROXY_WRAP_FUNCTION_RETURN_VALUES, info)) {\n    result = getTypeCheckedChild(createFn, info, 'returnValue', result);\n  }\n\n  return result;\n};\n\nlet getProperty$1;\nlet setProperty$1;\nlet callFunction$1;\n\nconst objectProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1\n});\n\nconst functionProxy = target => new Proxy(target, {\n  get: getProperty$1,\n  set: setProperty$1,\n  apply: callFunction$1,\n  construct: callFunction$1\n});\n\nconst wrapWithProxy = target => {\n  if (target instanceof Function) {\n    return functionProxy(target);\n  }\n\n  return objectProxy(target);\n};\n\nconst createInfoFromOptions = (target, {\n  deep = true,\n  names = [],\n  config = null,\n  children = null,\n  checker = getDefaultTypeChecker(),\n  info = null // exclusive option, if set other options being ignored\n} = {}) => info || createTargetInfo(checker, checker.init(target, getErrorReporter(), config), deep, names, createChildrenCache(children));\n\nconst create = (target, options) => {\n  if (!isValidTarget(target) || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  setTargetInfo(target, createInfoFromOptions(target, options));\n\n  return wrapWithProxy(target);\n};\n\ngetProperty$1 = getProperty(create);\nsetProperty$1 = setProperty(create);\ncallFunction$1 = callFunction(create);\n\nconst deepInitializer = (target, options) => {\n  const info = createInfoFromOptions(target, options);\n  const { deep, names, checker, config, children } = info;\n\n  Object.keys(target).forEach(name => {\n    const value = target[name];\n\n    checker.getProperty(target, name, value, config, names);\n\n    if (isValidTarget(value)) {\n      let childInfo = getChildInfo(children, name);\n\n      if (childInfo) {\n        deepInitializer(value, { info: childInfo });\n      } else {\n        childInfo = deepInitializer(value, {\n          deep,\n          names: [...names, name],\n          checker\n        });\n        storeChildInfo(children, name, childInfo);\n      }\n    }\n  });\n\n  setTargetInfo(target, info);\n\n  return info;\n};\n\nconst createDeep = (target, options) => {\n  if (!target || typeof target !== 'object' || !isEnabled() || isTypeChecked(target)) {\n    return target;\n  }\n\n  deepInitializer(target, options);\n\n  return wrapWithProxy(target);\n};\n\nconst merge = (options, ...sources) => {\n  let target = {};\n\n  if (isEnabled()) {\n    if (!options) {\n      options = {\n        info: getTargetInfo(sources.find(item => hasTargetInfo(item))),\n        deep: false\n      };\n    }\n\n    target = create(target, options);\n  }\n\n  return Object.assign(target, ...sources);\n};\n\n// TODO if enabled, replaces original value with type checked\nconst properties = (target, options = undefined, ...names) => {\n  if (!isEnabled()) {\n    return target;\n  }\n\n  if (!isValidTarget(target)) {\n    throw new Error('Target must be a valid object.');\n  }\n\n  if (Object.isFrozen(target) || Object.isSealed(target)) {\n    throw new Error('Target object should not be sealed or frozen.');\n  }\n\n  if (!names.length) {\n    // Symbols and non-enumerables must be explicitly specified\n    names = Object.keys(target);\n  }\n\n  const { length } = names;\n  for (let index = 0; index < length; index += 1) {\n    const name = names[index];\n    const { writable, get, set } = Object.getOwnPropertyDescriptor(target, name);\n\n    // Prohibit applying to properties with accessor/mutator pair?\n    if (get && set || writable) {\n      const value = target[name];\n\n      if (isValidTarget(value) && !isTypeChecked(value)) {\n        target[name] = create(value, options);\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.getDefaultTypeChecker = getDefaultTypeChecker;\nexports.setDefaultTypeChecker = setDefaultTypeChecker;\nexports.PROXY_WRAP_FUNCTION_RETURN_VALUES = PROXY_WRAP_FUNCTION_RETURN_VALUES;\nexports.PROXY_WRAP_FUNCTION_ARGUMENTS = PROXY_WRAP_FUNCTION_ARGUMENTS;\nexports.PROXY_WRAP_SET_PROPERTY_VALUES = PROXY_WRAP_SET_PROPERTY_VALUES;\nexports.PROXY_IGNORE_PROTOTYPE_METHODS = PROXY_IGNORE_PROTOTYPE_METHODS;\nexports.getDefaultProxyConfig = getDefaultProxyConfig;\nexports.setProxyConfig = setProxyConfig;\nexports.getProxyConfig = getProxyConfig;\nexports.create = create;\nexports.createDeep = createDeep;\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\nexports.getErrorReporter = getErrorReporter;\nexports.setErrorReporter = setErrorReporter;\nexports.isEnabled = isEnabled;\nexports.setEnabled = setEnabled;\nexports.getTargetInfo = getTargetInfo;\nexports.setTargetInfo = setTargetInfo;\nexports.hasTargetInfo = hasTargetInfo;\nexports.getTargetTypeChecker = getTargetTypeChecker;\nexports.getTargetTypeCheckerConfig = getTargetTypeCheckerConfig;\nexports.mergeTargetInfo = mergeTargetInfo;\nexports.getOriginalTarget = getOriginalTarget;\nexports.merge = merge;\nexports.properties = properties;\nexports.isTypeChecked = isTypeChecked;\nexports.isValidTarget = isValidTarget;\nexports.default = create;\n//# sourceMappingURL=type-checkers.js.map\n","import {\n  getTargetTypeChecker,\n  getTargetTypeCheckerConfig,\n} from '@actualwave/type-checkers';\n\nconst indexBasedClasses = [Array];\n\nexport const INDEX = '(Index)';\n\nexport const isIndexAccessTarget = (target) =>\n  target && indexBasedClasses.indexOf(target.constructor) >= 0;\n\nexport const registerIndexBasedClass = (constructor) => {\n  indexBasedClasses.push(constructor);\n};\n\nexport const setIndexValueType = (target, type) => {\n  const config = getTargetTypeCheckerConfig(target);\n\n  if (config) {\n    config.types[INDEX] = type || '';\n  }\n};\n\nexport const setIndexValueTypeBy = (target, value) => {\n  setIndexValueType(target, getTargetTypeChecker(target).getTypeString(value));\n};\n","import { ARGUMENTS, RETURN_VALUE } from '@actualwave/primitive-type-checker';\n\nimport { getTargetTypeCheckerConfig } from '@actualwave/type-checkers';\n\nimport { INDEX } from './indexed';\n\nexport const replacePropertyTypeCheck = (target, name, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[name];\n\n  if (fn) {\n    types[name] = fn;\n  }\n};\n\nexport const replaceArgumentsTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[ARGUMENTS];\n\n  if (fn) {\n    types[ARGUMENTS] = fn;\n  }\n};\n\nexport const replaceReturnValueTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[RETURN_VALUE];\n\n  if (fn) {\n    types[RETURN_VALUE] = fn;\n  }\n};\n\nexport const replaceIndexedTypeCheck = (target, fn) => {\n  const { types } = getTargetTypeCheckerConfig(target);\n  delete types[INDEX];\n\n  if (fn) {\n    types[INDEX] = fn;\n  }\n};\n","import PrimitiveTypeChecker, {\n  ARGUMENTS,\n  GET_PROPERTY,\n  RETURN_VALUE,\n  SET_PROPERTY,\n  AsIs,\n  checkPrimitiveType,\n} from '@actualwave/primitive-type-checker';\n\nimport {\n  INDEX,\n  isIndexAccessTarget,\n  registerIndexBasedClass,\n  setIndexValueType,\n  setIndexValueTypeBy,\n} from './indexed';\n\nimport {\n  replaceArgumentsTypeCheck,\n  replaceIndexedTypeCheck,\n  replacePropertyTypeCheck,\n  replaceReturnValueTypeCheck,\n} from './replace';\n\nclass ExtendedTypeChecker extends PrimitiveTypeChecker {\n  areArrayElementsOfSameType = true;\n  replacePropertyTypeCheck = replacePropertyTypeCheck;\n  replaceArgumentsTypeCheck = replaceArgumentsTypeCheck;\n  replaceReturnValueTypeCheck = replaceReturnValueTypeCheck;\n  replaceIndexedTypeCheck = replaceIndexedTypeCheck;\n  isIndexAccessTarget = isIndexAccessTarget;\n  registerIndexBasedClass = registerIndexBasedClass;\n  setIndexValueType = setIndexValueType;\n  setIndexValueTypeBy = setIndexValueTypeBy;\n\n  init(target, errorReporter, cachedTypes = null) {\n    const types = {};\n\n    if (\n      !cachedTypes &&\n      this.collectTypesOnInit &&\n      this.areArrayElementsOfSameType &&\n      isIndexAccessTarget(target)\n    ) {\n      const { length } = target;\n\n      for (let index = 0; index < length; index += 1) {\n        const type = this.getTypeString(target[index]);\n\n        if (type) {\n          types[INDEX] = type;\n          break;\n        }\n      }\n    } else {\n      return super.init(target, errorReporter, cachedTypes);\n    }\n\n    return {\n      types,\n      errorReporter,\n    };\n  }\n\n  getProperty(target, name, value, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.getIndexProperty(target, INDEX, value, config, sequence);\n    }\n\n    return this.getNamedProperty(target, name, value, config, sequence);\n  }\n\n  getIndexProperty(target, name, value, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    const type = this.getTypeString(value);\n\n    return checkPrimitiveType(\n      GET_PROPERTY,\n      types,\n      AsIs(INDEX),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  getNamedProperty(target, name, value, config, sequence) {\n    const typeFn = config.types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(GET_PROPERTY, target, name, value, config, sequence);\n    }\n\n    return super.getProperty(target, name, value, config, sequence);\n  }\n\n  setProperty(target, name, newValue, config, sequence) {\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\n      return this.setIndexProperty(target, INDEX, newValue, config, sequence);\n    }\n\n    return this.setNamedProperty(target, name, newValue, config, sequence);\n  }\n\n  setIndexProperty(target, name, newValue, config, sequence) {\n    const { types, errorReporter } = config;\n    const typeFn = types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    const type = this.getTypeString(newValue);\n\n    return checkPrimitiveType(\n      SET_PROPERTY,\n      types,\n      AsIs(INDEX),\n      type,\n      errorReporter,\n      sequence,\n    );\n  }\n\n  setNamedProperty(target, name, newValue, config, sequence) {\n    const typeFn = config.types[name];\n\n    if (typeFn instanceof Function) {\n      return typeFn(SET_PROPERTY, target, name, newValue, config, sequence);\n    }\n\n    return super.setProperty(target, name, newValue, config, sequence);\n  }\n\n  arguments(target, thisArg, args, config, sequence) {\n    const typeFn = config.types[ARGUMENTS];\n\n    if (typeFn instanceof Function) {\n      return typeFn(ARGUMENTS, target, args, config, sequence);\n    }\n\n    return super.arguments(target, thisArg, args, config, sequence);\n  }\n\n  returnValue(target, thisArg, value, config, sequence) {\n    const typeFn = config.types[RETURN_VALUE];\n\n    if (typeFn instanceof Function) {\n      return typeFn(RETURN_VALUE, target, value, config, sequence);\n    }\n\n    return super.returnValue(target, thisArg, value, config, sequence);\n  }\n}\n\nexport {\n  isIndexAccessTarget,\n  registerIndexBasedClass,\n  setIndexValueType,\n  setIndexValueTypeBy,\n  replaceArgumentsTypeCheck,\n  replaceIndexedTypeCheck,\n  replacePropertyTypeCheck,\n  replaceReturnValueTypeCheck,\n  ExtendedTypeChecker,\n};\n\nexport default ExtendedTypeChecker;\n","const primitive = require('@actualwave/primitive-type-checker');\nconst typeCheckers = require('@actualwave/type-checkers');\nconst extended = require('./index');\n\ntypeCheckers.setDefaultTypeChecker(new extended.ExtendedTypeChecker());\n\nObject.assign(exports, primitive, extended, typeCheckers);\n"],"names":["Object","defineProperty","exports","value","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","ex","require$$0","ARGUMENTS","RETURN_VALUE","AsIs","this","asIs","toString","valueOf","Symbol","toPrimitive","buildPath","sequence","reduce","str","name","String","parseInt","test","checkPrimitiveType","action","types","type","errorReporter","storedType","mergeConfigs","source","names","sourceTypes","sourceType","targetType","getTypeString","undefined","Array","propertyCheckerFactory","config","getPropertyChecker","setPropertyChecker","PrimitiveTypeChecker","[object Object]","collectTypesOnInit","cachedTypes","keys","forEach","key","thisArg","args","length","valid","index","defaultTypeChecker","getDefaultTypeChecker","getDefaultProxyConfig","wrapFunctionReturnValues","wrapFunctionArguments","wrapSetPropertyValues","ignorePrototypeMethods","getProxyConfigValue","info","constructErrorString","required","received","ConsoleErrorReporter","requiredTypeString","actualTypeString","console","error","getErrorReporter","enabled","isEnabled","INFO_KEY","createChildrenCache","children","assign","getTargetInfo","setTargetInfo","hasTargetInfo","getChildInfoKey","storeChildInfo","cache","childInfo","storeChildInfoFrom","child","getChildInfo","mergeTargetInfo","targetInfo","sourceInfo","deep","checker","targetCache","sourceCache","mergeChildrenCache","TARGET_KEY","validTypes","object","function","isValidTarget","isTypeChecked","getTypeCheckedChild","createFn","result","getProperty$1","setProperty$1","callFunction$1","wrapWithProxy","Function","Proxy","get","set","apply","construct","functionProxy","objectProxy","createInfoFromOptions","createTargetInfo","init","create","options","getProperty","isIgnoredProperty","getTargetProperty","Error","setProperty","setNonTargetProperty","setTargetProperty","argumentsList","arguments","getTargetArguments","returnValue","callFunction","deepInitializer","typeChecker","newConfig","warn","receivedTypeString","reporter","sources","find","item","isFrozen","isSealed","writable","getOwnPropertyDescriptor","indexBasedClasses","INDEX","isIndexAccessTarget","indexOf","constructor","registerIndexBasedClass","push","setIndexValueType","getTargetTypeCheckerConfig","setIndexValueTypeBy","getTargetTypeChecker","replacePropertyTypeCheck","fn","replaceArgumentsTypeCheck","replaceReturnValueTypeCheck","replaceIndexedTypeCheck","ExtendedTypeChecker","areArrayElementsOfSameType","super","getIndexProperty","getNamedProperty","typeFn","GET_PROPERTY","newValue","setIndexProperty","setNamedProperty","SET_PROPERTY","typeCheckers","setDefaultTypeChecker","extended","primitive"],"mappings":"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"}