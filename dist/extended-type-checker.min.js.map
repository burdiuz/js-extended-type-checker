{"version":3,"file":"extended-type-checker.min.js","sources":["../node_modules/@actualwave/type-checker-simple-reporting/index.js","../node_modules/@actualwave/has-own/has-own.js","../node_modules/@actualwave/map-of-sets/index.js","../node_modules/@actualwave/type-checker-levels-storage/index.js","../node_modules/@actualwave/primitive-type-checker/index.js","../node_modules/@actualwave/get-class/get-class.js","../source/indexed.js","../node_modules/@actualwave/is-function/is-function.js","../source/extended.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable import/prefer-default-export */\n\nconst constructErrorString = (action, name, required, received) => `${action}Error on \"${name}\" instead of \"${required}\" received \"${received}\"`;\n\n/* eslint-disable no-console */\n\nconst ConsoleErrorReporter = (action, name, requiredTypeString, actualTypeString) => console.error(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\nconst ConsoleWarnReporter = (action, name, requiredTypeString, actualTypeString) => console.warn(constructErrorString(action, name, requiredTypeString, actualTypeString));\n\n/* eslint-disable import/prefer-default-export */\n\nconst ThrowErrorReporter = (action, name, requiredTypeString, receivedTypeString) => {\n  throw new Error(constructErrorString(action, name, requiredTypeString, receivedTypeString));\n};\n\nexports.ConsoleErrorReporter = ConsoleErrorReporter;\nexports.ConsoleWarnReporter = ConsoleWarnReporter;\nexports.ThrowErrorReporter = ThrowErrorReporter;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst hasOwn = (\n  (has) =>\n  (target, property) =>\n  Boolean(target && has.call(target, property))\n)(Object.prototype.hasOwnProperty);\n\nexports.hasOwn = hasOwn;\nexports.default = hasOwn;","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nclass MapOfSets {\n  constructor() {\n    this.storage = new Map();\n  }\n  /**\r\n   * Check if key exists\r\n   * @param {*} key\r\n   */\n\n\n  has(key) {\n    const values = this.storage.get(key);\n    return values && values.size;\n  }\n  /**\r\n   * Check if value exists for key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  hasValue(key, value) {\n    const values = this.storage.get(key);\n    return values && values.has(value);\n  }\n  /**\r\n   * Get Set of values for key\r\n   * @param {*} key\r\n   */\n\n\n  get(key) {\n    return this.storage.get(key);\n  }\n  /**\r\n   * List values for key, returns empty array if no key nor values stored\r\n   * @param {*} key\r\n   */\n\n\n  list(key) {\n    const values = this.storage.get(key);\n    return values ? Array.from(values) : [];\n  }\n  /**\r\n   * Call callback for each value of each key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {Function} callback\r\n   */\n\n\n  forEach(callback) {\n    this.storage.forEach((values, key) => values.forEach(value => callback(value, key, this)));\n  }\n  /**\r\n   * Call callback function for each value of specified key\r\n   *  callback (value:*, key:*, storage:*):void\r\n   * @param {*} key\r\n   * @param {Function} callback\r\n   */\n\n\n  eachValue(key, callback) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.forEach(value => callback(value, key, this));\n    }\n  }\n  /**\r\n   * Add to new value to key.\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  add(key, value) {\n    if (!value) return;\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.add(value);\n    } else {\n      this.storage.set(key, new Set([value]));\n    }\n  }\n  /**\r\n   * Replace all values for key\r\n   * @param {*} key\r\n   * @param {Set} types\r\n   */\n\n\n  set(key, values) {\n    if (!values || values.size === 0) {\n      this.remove(key);\n      return;\n    }\n\n    this.storage.set(key, new Set(values));\n  }\n  /**\r\n   * Remove all values for key\r\n   * @param {*} key\r\n   */\n\n\n  remove(key) {\n    this.storage.delete(key);\n  }\n  /**\r\n   * Remove single value from key\r\n   * @param {*} key\r\n   * @param {*} value\r\n   */\n\n\n  removeValue(key, value) {\n    const values = this.storage.get(key);\n\n    if (values) {\n      values.delete(value);\n\n      if (!values.size) {\n        this.remove(key);\n      }\n    }\n  }\n  /**\r\n   * Clone all key-value stores\r\n   */\n\n\n  clone() {\n    const target = new MapOfSets();\n    this.storage.forEach((values, key) => target.set(key, new Set(values)));\n    return target;\n  }\n\n}\nconst createMapOfSets = () => new MapOfSets();\n\nexports.MapOfSets = MapOfSets;\nexports.createMapOfSets = createMapOfSets;\nexports.default = MapOfSets;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hasOwn = _interopDefault(require('@actualwave/has-own'));\nvar MapOfSets = _interopDefault(require('@actualwave/map-of-sets'));\n\n/**\n * Do not check or report type inconsistency\n */\nconst REPORT_NEVER = 'never';\n/**\n * Report type inconsistency once, i.e. record all types and report new\n */\nconst REPORT_ONCE = 'once';\n/**\n * Report whenever type is inconsistent with initial\n */\nconst REPORT_ALL = 'all';\n\nconst REPORT_KEY = Symbol('type-checkers:report-level');\nconst PROPERTY_REPORT_KEY = Symbol('type-checkers:property-report-level');\n\nlet globalReportingLevel = REPORT_ALL;\n\nconst validateReportingLevel = level => {\n  switch (level) {\n    case REPORT_NEVER:\n    case REPORT_ONCE:\n      return level;\n    default:\n      return REPORT_ALL;\n  }\n};\n\nconst setGlobalReportingLevel = level => {\n  globalReportingLevel = validateReportingLevel(level);\n};\n\nconst getGlobalReportingLevel = () => globalReportingLevel;\n\nconst setTargetGeneralReportingLevel = (target, level) => {\n  if (level) {\n    target[REPORT_KEY] = validateReportingLevel(level);\n  } else {\n    delete target[REPORT_KEY];\n  }\n};\n\nconst setTargetPropertyReportingLevel = (target, perPropertyLevels) => {\n  if (!perPropertyLevels) {\n    delete target[PROPERTY_REPORT_KEY];\n    return;\n  }\n\n  target[PROPERTY_REPORT_KEY] = Object.keys(perPropertyLevels).reduce((levels, prop) => {\n    levels[prop] = validateReportingLevel(perPropertyLevels[prop]);\n    return levels;\n  }, {});\n};\n\nconst setReportingLevel = (target, generalLevel, perPropertyLevels) => {\n  setTargetGeneralReportingLevel(target, generalLevel);\n  setTargetPropertyReportingLevel(target, perPropertyLevels);\n};\n\nconst getTargetReportingLevel = (target, key) => {\n  if (hasOwn(target[PROPERTY_REPORT_KEY], key)) {\n    return target[PROPERTY_REPORT_KEY][key];\n  }\n\n  return target[REPORT_KEY];\n};\n\nconst getReportingLevel = (target, key) => {\n  let level = getTargetReportingLevel(target, key);\n\n  if (!level) {\n    level = getTargetReportingLevel(target.constructor, key);\n  }\n\n  return level || getGlobalReportingLevel();\n};\n\n/**\n *\n * @param {any} key\n * @param {Set} target\n * @param {Set} source\n */\nconst defaultMergeStrategy = (key, target, source) => {\n  source.forEach(type => {\n    if (!target.has(type)) {\n      target.add(type);\n    }\n  });\n\n  return target;\n};\n\nclass TypeInfoStorage extends MapOfSets {\n  /**\n   * Add to type information for specified key.\n   * @param {*} key\n   * @param {*} type\n   * @param {Number} level\n   */\n  add(key, type, level) {\n    if (!type) return;\n\n    switch (level) {\n      case REPORT_NEVER:\n        this.remove(key);\n        break;\n      case REPORT_ONCE:\n        super.add(key, type);\n        break;\n      case REPORT_ALL:\n      default:\n        {\n          const types = this.storage.get(key);\n\n          if (!types || !types.size) {\n            this.storage.set(key, new Set([type]));\n          }\n        }\n        break;\n    }\n  }\n\n  addFor(key, type, target) {\n    this.add(key, type, getReportingLevel(target, key));\n  }\n\n  /**\n   * Replace types information for specific key\n   * @param {*} key\n   * @param {Set} types\n   * @param {Number} level\n   */\n  set(key, types, level) {\n    if (!types || types.size === 0 || level === REPORT_NEVER) {\n      this.remove(key);\n      return;\n    }\n\n    super.set(key, types);\n  }\n\n  /**\n   *\n   * @param {*} key\n   * @param {Set} types\n   * @param {Object} target\n   */\n  setFor(key, types, target) {\n    return this.set(key, types, getReportingLevel(target, key));\n  }\n\n  clone() {\n    const target = new TypeInfoStorage();\n    this.storage.forEach((types, key) => target.set(key, new Set(types)));\n\n    return target;\n  }\n\n  /**\n   * Copy types from current storage to storage passed as first argument.\n   * @param {Map} storage\n   * @param {Object} [target]\n   * @param {Function} [mergeStrategy]\n   */\n  copyTo(storage, target, mergeStrategy = defaultMergeStrategy) {\n    this.storage.forEach((types, key) => {\n      const level = validateReportingLevel(target && getReportingLevel(target, key));\n\n      switch (level) {\n        case REPORT_ALL:\n        case REPORT_ONCE:\n          if (storage.has(key)) {\n            storage.set(key, mergeStrategy(key, storage.get(key), types, level), level);\n          } else {\n            storage.set(key, new Set(types));\n          }\n          break;\n        case REPORT_NEVER:\n        default:\n          break;\n      }\n    });\n\n    return storage;\n  }\n}\n\nconst createTypesStorage = () => new TypeInfoStorage();\n\nexports.REPORT_ALL = REPORT_ALL;\nexports.REPORT_NEVER = REPORT_NEVER;\nexports.REPORT_ONCE = REPORT_ONCE;\nexports.createTypesStorage = createTypesStorage;\nexports.defaultMergeStrategy = defaultMergeStrategy;\nexports.getGlobalReportingLevel = getGlobalReportingLevel;\nexports.setGlobalReportingLevel = setGlobalReportingLevel;\nexports.getReportingLevel = getReportingLevel;\nexports.setReportingLevel = setReportingLevel;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar typeCheckerSimpleReporting = require('@actualwave/type-checker-simple-reporting');\nvar typeCheckerLevelsStorage = require('@actualwave/type-checker-levels-storage');\n\nlet errorReporter = typeCheckerSimpleReporting.ConsoleErrorReporter;\nconst getErrorReporter = () => errorReporter;\nconst setErrorReporter = value => {\n  errorReporter = value;\n};\n\nconst MERGE = '(Merge)';\nconst GET_PROPERTY = '(GetProperty)';\nconst SET_PROPERTY = '(SetProperty)';\nconst ARGUMENTS = '(Arguments)';\nconst RETURN_VALUE = '(ReturnValue)';\nconst checkPrimitiveType = (storage, key, type) => {\n  return !storage.has(key) || storage.hasValue(key, type);\n};\nconst getTypeValue = value => {\n  if (value === undefined) {\n    return '';\n  }\n\n  const type = typeof value;\n\n  if (type === 'object' && value instanceof Array) {\n    return 'array';\n  }\n\n  return type;\n};\n\n/* eslint-disable class-methods-use-this */\n\nclass PrimitiveTypeChecker {\n  constructor(collectTypesOnInit = true, enableGetChecker = true) {\n    this.collectTypesOnInit = collectTypesOnInit;\n    this.enableGetChecker = enableGetChecker;\n  }\n\n  init(target, cachedStorage = null) {\n    let storage;\n\n    if (cachedStorage) {\n      storage = cachedStorage;\n    } else if (this.collectTypesOnInit) {\n      storage = typeCheckerLevelsStorage.createTypesStorage();\n      Object.keys(target).forEach(key => storage.addFor(key, this.getTypeValue(target[key]), target));\n    }\n\n    return storage;\n  }\n\n  getTypeValue(value) {\n    return getTypeValue(value);\n  }\n\n  checkValueType(action, storage, target, names, type) {\n    if (!type) {\n      return true;\n    }\n\n    const {\n      lastName\n    } = names;\n    const compatible = this.isTypeCompatible(storage, lastName, type, target);\n\n    if (!compatible) {\n      const errorReporter = getErrorReporter();\n      errorReporter(action, names.toString(), storage.list(lastName), type);\n    }\n\n    storage.addFor(lastName, type, target);\n    return compatible;\n  }\n\n  isTypeCompatible(storage, key, type) {\n    return checkPrimitiveType(storage, key, type);\n  }\n  /**\n   * FIXME add function to @actualwave/type-checker-levels-storage to merge configs\n   * this function should accept storages and merge strategy callback which will\n   * receive type info and decide what should be merged and what not\n   */\n\n\n  mergeConfigs(storage, sourceStorage, names) {\n    const errorReporter = getErrorReporter();\n    sourceStorage.copyTo(storage, null, (key, target, source) => {\n      const targetFirstValue = target.values().next().value;\n      source.forEach(sourceType => {\n        if (!target.has(sourceType)) {\n          target.add(sourceType);\n\n          if (targetFirstValue) {\n            errorReporter(MERGE, names, targetFirstValue, sourceType);\n          }\n        }\n      });\n      return target;\n    });\n  }\n\n  getProperty(target, names, value, storage) {\n    if (!this.enableGetChecker) {\n      return true;\n    }\n\n    const type = this.getTypeValue(value);\n    return this.checkValueType(GET_PROPERTY, storage, target, names, type);\n  }\n\n  setProperty(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n    return this.checkValueType(SET_PROPERTY, storage, target, names, type);\n  }\n\n  arguments(target, names, args, storage) {\n    const {\n      length\n    } = args;\n    let valid = true;\n\n    for (let index = 0; index < length; index++) {\n      const type = this.getTypeValue(args[index]);\n      const agrValid = this.checkValueType(ARGUMENTS, storage, target, names.clone(index), type);\n      valid = agrValid && valid;\n    }\n\n    return valid;\n  }\n\n  returnValue(target, names, value, storage) {\n    const type = this.getTypeValue(value);\n    const callNames = names.clone();\n    callNames.appendCustomValue(RETURN_VALUE);\n    return this.checkValueType(RETURN_VALUE, storage, target, callNames, type);\n  }\n\n}\n\nconst createPrimitiveTypeChecker = (collectTypesOnInit = true, enableGetChecker = true) => new PrimitiveTypeChecker(collectTypesOnInit, enableGetChecker);\n\nexports.REPORT_ALL = typeCheckerLevelsStorage.REPORT_ALL;\nexports.REPORT_NEVER = typeCheckerLevelsStorage.REPORT_NEVER;\nexports.REPORT_ONCE = typeCheckerLevelsStorage.REPORT_ONCE;\nexports.getGlobalReportingLevel = typeCheckerLevelsStorage.getGlobalReportingLevel;\nexports.setGlobalReportingLevel = typeCheckerLevelsStorage.setGlobalReportingLevel;\nexports.getReportingLevel = typeCheckerLevelsStorage.getReportingLevel;\nexports.setReportingLevel = typeCheckerLevelsStorage.setReportingLevel;\nexports.MERGE = MERGE;\nexports.ARGUMENTS = ARGUMENTS;\nexports.GET_PROPERTY = GET_PROPERTY;\nexports.RETURN_VALUE = RETURN_VALUE;\nexports.SET_PROPERTY = SET_PROPERTY;\nexports.checkPrimitiveType = checkPrimitiveType;\nexports.getTypeValue = getTypeValue;\nexports.PrimitiveTypeChecker = PrimitiveTypeChecker;\nexports.createPrimitiveTypeChecker = createPrimitiveTypeChecker;\nexports.getErrorReporter = getErrorReporter;\nexports.setErrorReporter = setErrorReporter;\nexports.default = PrimitiveTypeChecker;\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst getProtoConstructor = (value) => {\n  const proto = Object.getPrototypeOf(value);\n\n  if (proto && typeof proto === 'object') {\n    return proto.constructor;\n  }\n\n  return proto || Object;\n}\n\nconst getClass = (value) => {\n  if(value === null || value === undefined) {\n    return undefined;\n  }\n\n  const constructor = value.constructor;\n\n  if(\n    typeof constructor === 'function'\n    && value instanceof constructor\n  ) {\n    return value.constructor;\n  }\n\n  return getProtoConstructor(value);\n};\n\nconst getParentClass = (value) => getProtoConstructor(getClass(value));\n\nconst getClassName = (value) => {\n  if (!value) return '';\n\n  const def = getClass(value);\n\n  return def ? def.name : '';\n};\n\nexports.getClassName = getClassName;\nexports.getParentClass = getParentClass;\nexports.getClass = getClass;\nexports.default = getClass;\n","import { getClass } from '@actualwave/get-class';\nimport { getTypeValue } from '@actualwave/primitive-type-checker';\nimport { getTypeCheckerData } from '@actualwave/type-checkers';\n\nconst indexBasedClasses = new Set([Array]);\n\nexport const INDEX = '(Index)';\n\nexport const isIndexAccessTarget = (target) => !!target && indexBasedClasses.has(getClass(target));\n\nexport const registerIndexBasedClass = (constructor) => {\n  indexBasedClasses.add(constructor);\n};\n\nexport const setIndexValueType = (target, type) => {\n  const storage = getTypeCheckerData(target);\n\n  if (storage && type) {\n    storage.set(INDEX, new Set([type]));\n  }\n};\n\nexport const setIndexValueTypeBy = (target, value) => {\n  setIndexValueType(target, getTypeValue(value));\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isFunction = (target) => (typeof target === 'function');\n\nexports.isFunction = isFunction;\nexports.default = isFunction;","import { createTypesStorage } from '@actualwave/type-checker-levels-storage';\r\nimport isFunction from '@actualwave/is-function';\r\n\r\nimport PrimitiveTypeChecker, {\r\n  GET_PROPERTY,\r\n  SET_PROPERTY,\r\n} from '@actualwave/primitive-type-checker';\r\n\r\nimport { INDEX, isIndexAccessTarget } from './indexed';\r\n\r\nconst isOptionalFunction = (value, name) => {\r\n  if (value !== undefined && !isFunction(value)) {\r\n    throw new Error(`\"${name}\" must be a callable object, i.e. function.`);\r\n  }\r\n};\r\n\r\nclass ExtendedTypeChecker extends PrimitiveTypeChecker {\r\n  constructor({\r\n    collectTypesOnInit = true,\r\n    enableGetChecker = true,\r\n    areArrayElementsOfSameType = true,\r\n    customTypeResolver = undefined,\r\n    customTypeComparator = undefined,\r\n  } = {}) {\r\n    super(collectTypesOnInit, enableGetChecker);\r\n\r\n    this.areArrayElementsOfSameType = areArrayElementsOfSameType;\r\n\r\n    this.customTypeResolver = customTypeResolver;\r\n    isOptionalFunction(this.customTypeResolver, 'customTypeResolver');\r\n\r\n    this.customTypeComparator = customTypeComparator;\r\n    isOptionalFunction(this.customTypeComparator, 'customTypeComparator');\r\n  }\r\n\r\n  getTypeValue(value) {\r\n    if (this.customTypeResolver) {\r\n      return this.customTypeResolver(value);\r\n    }\r\n\r\n    return super.getTypeValue(value);\r\n  }\r\n\r\n  isTypeCompatible(storage, key, type, target) {\r\n    if (this.customTypeComparator) {\r\n      return this.customTypeComparator(storage, key, type, target);\r\n    }\r\n\r\n    return super.isTypeCompatible(storage, key, type, target);\r\n  }\r\n\r\n  findIndexedType(target) {\r\n    const { length } = target;\r\n\r\n    for (let index = 0; index < length; index += 1) {\r\n      const type = this.getTypeValue(target[index]);\r\n\r\n      if (type) {\r\n        return type;\r\n      }\r\n    }\r\n\r\n    return '';\r\n  }\r\n\r\n  init(target, cachedStorage = null) {\r\n    if (\r\n      !cachedStorage &&\r\n      this.collectTypesOnInit &&\r\n      this.areArrayElementsOfSameType &&\r\n      isIndexAccessTarget(target)\r\n    ) {\r\n      const storage = createTypesStorage();\r\n      const type = this.findIndexedType(target);\r\n\r\n      if (type) {\r\n        storage.add(INDEX, type);\r\n        return storage;\r\n      }\r\n    }\r\n\r\n    return super.init(target, cachedStorage);\r\n  }\r\n\r\n  getProperty(target, names, value, storage) {\r\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\r\n      return this.getIndexProperty(target, names, value, storage);\r\n    }\r\n\r\n    return super.getProperty(target, names, value, storage);\r\n  }\r\n\r\n  getIndexProperty(target, names, value, storage) {\r\n    const nextNames = names.clone();\r\n\r\n    nextNames.appendCustomValue(INDEX);\r\n\r\n    return this.checkValueType(GET_PROPERTY, storage, target, nextNames, this.getTypeValue(value));\r\n  }\r\n\r\n  setProperty(target, names, newValue, storage) {\r\n    if (this.areArrayElementsOfSameType && isIndexAccessTarget(target)) {\r\n      return this.setIndexProperty(target, names, newValue, storage);\r\n    }\r\n\r\n    return super.setProperty(target, names, newValue, storage);\r\n  }\r\n\r\n  setIndexProperty(target, names, newValue, storage) {\r\n    const nextNames = names.clone();\r\n\r\n    nextNames.appendCustomValue(INDEX);\r\n\r\n    return this.checkValueType(SET_PROPERTY, storage, target, nextNames, this.getTypeValue(newValue));\r\n  }\r\n}\r\n\r\nexport const createExtendedTypeChecker = (options) => new ExtendedTypeChecker(options);\r\n\r\nexport default ExtendedTypeChecker;\r\n"],"names":["Object","defineProperty","exports","value","constructErrorString","action","name","required","received","requiredTypeString","actualTypeString","console","error","warn","receivedTypeString","Error","hasOwn","has","target","property","Boolean","call","prototype","hasOwnProperty","MapOfSets","[object Object]","this","storage","Map","key","values","get","size","Array","from","callback","forEach","add","set","Set","remove","delete","_interopDefault","ex","require$$0","require$$1","REPORT_NEVER","REPORT_ONCE","REPORT_ALL","REPORT_KEY","Symbol","PROPERTY_REPORT_KEY","globalReportingLevel","validateReportingLevel","level","getGlobalReportingLevel","getTargetReportingLevel","getReportingLevel","constructor","defaultMergeStrategy","source","type","TypeInfoStorage","super","types","mergeStrategy","generalLevel","perPropertyLevels","setTargetGeneralReportingLevel","keys","reduce","levels","prop","setTargetPropertyReportingLevel","errorReporter","typeCheckerSimpleReporting","ConsoleErrorReporter","getErrorReporter","MERGE","GET_PROPERTY","SET_PROPERTY","ARGUMENTS","RETURN_VALUE","checkPrimitiveType","hasValue","getTypeValue","undefined","PrimitiveTypeChecker","collectTypesOnInit","enableGetChecker","cachedStorage","typeCheckerLevelsStorage","createTypesStorage","addFor","names","lastName","compatible","isTypeCompatible","toString","list","sourceStorage","copyTo","targetFirstValue","next","sourceType","checkValueType","args","length","valid","index","clone","callNames","appendCustomValue","setGlobalReportingLevel","setReportingLevel","getProtoConstructor","proto","getPrototypeOf","getClass","def","indexBasedClasses","INDEX","isIndexAccessTarget","setIndexValueType","getTypeCheckerData","isFunction","isOptionalFunction","ExtendedTypeChecker","areArrayElementsOfSameType","customTypeResolver","customTypeComparator","findIndexedType","init","getProperty","getIndexProperty","nextNames","setProperty","newValue","setIndexProperty","options"],"mappings":"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"}